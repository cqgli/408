# 绪论

----

## 数据结构的基本概念

### 基本概念和术语

1. 数据：信息的载体
2. 数据元素：数据的基本单位，由若干个数据项组成
3. 数据对象：相同性质的数据元素的集合
4. 数据类型：一个值的集合和定义在此集合上的一组操作打的总称
   1. 原子类型：不可再分
   2. 结构类型：可以分成若干分的数据类型
   3. 抽象数据类型
5. 数据结构：相互存在一种或多种特定关系的数据元素的集合

### 数据结构三要素

1. 数据逻辑结构
   1. 集合
   2. 线性结构 一对一
   3. 树形结构 一对多
   4. 图状结构或网状结构 多对多
2. 数据的存储结构
   1. 顺序存储 
   2. 链式存储
   3. 索引存储
   4. 散列存储
3. 数据的运算

## 算法和算法评价

### 算法的基本概念

1. 五个特性
   1. 有穷性
   2. 确定性
   3. 可行性
   4. 输入
   5. 输出
2. 好算法标志
   1. 正确性
   2. 可读性
   3. 健壮性
   4. 高效性和低存储

### 算法效率的度量

1. 时间复杂度
   1. 大O表示法
2. 空间复杂度
   1. 大O表示法

# 线性表

_____

## 线性表的存储结构

### 顺序存储-顺序表

### 链式存储

1. 单链表
2. 双链表
3. 循环链表
4. 静态链表

## 线性表的定义和基本操作

### 线性表的定义

1. 线性表是具有相同数据类型·的n个数据元素的有限序列
2. 表头元素
3. 表尾元素
4. 特点
   1. 表中元素个数有限
   2. 表中元素具有逻辑上的顺序性，具有先后次序
   3. 元素都是数据元素，每个元素都是单个元素
   4. 每个元素都是相同的，每个元素所占的空间相同
   5. 元素具有抽象性
5. **线性表是一种逻辑结构，表示元素之间一对一的关系**
6. **顺序表和链表表示存储结构**

### 线性表的基本操作

1. InitList(&L)：初始化表
2. Length(L),：求表长
3. LocateElem(L,e) ; 按值查找
4. GetElem（L,i)按位查找
5. ListInsert(&L,e,i)在特定位置插入e
6. ListDelete(&L,i，&e)删除第i个位置的元素并将其值返回e
7. PrintList(L)：输出表
8. Empty(L) :判空
9. DestroyList(&L) ：销毁表

## 线性表的顺序表示

### 顺序表的定义

1. 线性表的顺序存储也称顺序表
2. 特点：表中元素的逻辑顺序和存储的物理顺序相同
3. 位序：从1开始，下标：从0开始
4. 优点：
   1. 可以随机访问，O1
   2. 存储密度高
5. 缺点：
   1. 删除和插入需要移动大量元素
   2. 顺序存储分配空间不灵活

### 顺序表的基本操作的实现

1. InitList(&L) ：静态顺序表的初始化
2. InitList(&L):动态顺序表的初始化
3. ListInsert(&L,i,e)：顺序表的插入
4. ListDelete(&L,i,&e)：顺序表的删除
5. LocateElem(L,e)：按值查找
6. LocateElem(L,i)按位查找

## 线性表的链式表示

## 单链表的定义

1. 线性表的链式储存也称单链表
2. 特点：非随机存取的存储结构
3. 头指针，头结点
4. 头结点的优点
   1. 第一个位置的节点和其他位置操作相同
   2. 无论链表是否为空，头指针都是指向头结点，空链表和非空表处理统一

### 单链表的基本操作

1. InitList(&L):单链表的初始化
2. Length(L):求表长
3. GetElem(L,i)返回序号为i的结点
4. LocateElem(L,e)返回值为e的节点
5. ListInsert(&L,i,e)在指定位置插入e
6. ListDelete(&L,i,&e)删除指定位置并返回e
7. List_HeadInsert(&L)头插法建立单链表
8. List_TailInsert(&L)尾插法建立单链表

### 双链表

1. 双链表的插入
2. 删除

### 循环链表

1. 循环单链表
   1. 设置尾指针表头表尾插入操作为O1
   2. 设置头指针表头插入为O1，表尾插入为On
   3. 尾指针的next为头指针
2. 循环双链表
   1. 头结点prior指向表尾节点
   2. 尾节点的next指向头结点
   3. 当为空表是头结点的prior和next都指向L
3. 静态链表
   1. 采用数组的描述链式存储

## 顺序表和链表的比较

1. 存储方式
   1. 一个既可以顺序存取，又可以随机存取
   2. 链表只能顺序存取
2. 逻辑结构和物理结构
   1. 顺序表的逻辑和物理位置有关系
   2. 链表的逻辑和物理位置没有关系
3. 查找删除插入操作
   1. 按值查找：
      1. 顺序表无序时，均为On
      2. 有序是顺序表为O(log2n)
   2. 按位查找
      1. 顺序表O1
      2. 链表On
   3. 插入删除
      1. 顺序表需要移动元素
      2. 链表不需要
   4. 空间分配
      1. 不知道存储规模的时候可以使用链表
      2. 当按序访问多的时候优先顺序表
      3. 当插入删除多的时候优先链表

# 栈，队列，数组

## 栈

### 栈的基本概念

1. 栈的定义
   1. 只允许在一端进行插入删除操作的线性表。
   2. 栈顶：线性表允许插入删除的一端
   3. 栈底：不允许插入删除的一端
   4. 空栈：不含任何元素
2. 栈的基本操作
   1. InitStack（&S);初始化一个空栈
   2. StackEmpty（S);判断一个栈是否为空
   3. Push(&S,x)：入栈，**先判断栈满**,
   4. Pop(&S,&x)，出栈，**先判断栈空**，将出栈元素赋值给x
   5. GetTop（S,&X),获取栈顶元素，**先判断栈空**,赋值给x
   6. DestroyStack（&s) ，销毁栈，释放S占用空间，**当为动态栈的时候，可以释放，静态自动释放，设置top = -1**
3. 当n个不同元素入栈的时候，出栈的不同排列顺序由1/n+1Cn,2n  个，为卡特兰公式

### 栈的顺序存储结构

1. 顺序栈的实现
2. 顺序栈的基本操作
   1. 初始化
   2. 判空，判满
   3. 出入栈
   4. 获取栈顶元素
   5. 销毁
3. 共享栈
   1. 开始都指向栈顶元素top0 = -1，top1 = maxsize，**两个判空条件**
   2. 当top0+1 == top1 时，判断栈满
   3. 0栈，先++ ，后入栈，1栈，先--，后入栈
   4. 0栈，先出栈，再--，1栈，先出栈，再++；

### 链栈

1. **带头结点**
2. **带头指针**
3. **带尾指针**
4. **带尾节点**

## 队列

### 队列的基本概念

1. 队列的定义
   1. 只允许在表的一端进行出队或者离队
   2. 队头：允许删除一端
   3. 队尾：允许插入一端
   4. 空队列：不含任何元素的空表
2. 常见基本操作
   1. InitQueue（&Q)，初始化队列，构建空队
   2. QueueEmpty(Q);判断队空
   3. EnQueue(&Q,x)，向一个队列中加入x，**先判断队满**
   4. DeQueue（&Q,&x)，删除队头元素，并赋值给x，**先判断队空**
   5. GetHead（Q,&x),获取队首元素，**先判断队空**

### 队列的顺序存储

1. 队列的顺序存储
   1. 队空条件
      1. Q.front == Q.rear == 0
   2. 入队
      1. 先赋值，队尾++
   3. 出队
      1. 先取值，队头++
2. **循环队列** 
   1. 判断空
      1. Q.rear == Q.front
   2. 判满（**舍弃一个储存空间**)
      1. (Q.rear+1)%maxsize == Q.front;
   3. **长度**
      1. 可以理解为队头往右然后到最后，在从开头到队尾的长度
      2. （Q.rear-Q.front+maxsize）%maxsize
   4. 入队
      1. 先判满
      2. 队尾+1模%maxsize
   5. 出队
      1. 先判空
      2. 队头+1%maxsize

### 队列的链式存储

1. 队列的链式存储
2. 判空（默认存在头结点）
   1. Q.front == Q.rear == NULL
3. 初始化
4. 入队
   1. 先判断是否为第一个节点
      1. 是则将Q.front->next = s;
   2. Q.rear->next = s
   3. s.next = NULL;
   4. Q.rear = s;
5. 出队
   1. 判空
   2. L = Q.front->next;
   3. Q.front->next = L->next;
   4. 判断是否为最后一个节点
      1. 是则Q.rear = NULL;
   5. free(L)；

### 双端队列

1. 输入输出受限
2. 两端的输入输出受限的各种形式

## 栈和队列的应用

### 栈在括号匹配的应用

1. 初始化空栈
2. 如果是左括号就入栈
3. 如果是右括号，就出栈，匹配则继续，**栈空时则不匹配**

### 栈在表达式求值的应用

1. 算术表达式
2. 中缀表达式转后缀表达式
   1. 初始化栈
   2. 操作数直接进如数组
   3. 当左括号时，直接入栈，右括号时，依次弹出左右括号之间的运算符
   4. 当遇到运算符，判断站内运算符，优先级大于等于该运算符的运算符弹出
   5. 压入该运算符
3. 后缀表达式求值
   1. 初始化栈
   2. 操作数入栈
   3. 遇到运算符取两个操作数，**先取出的是右操作数，后取出的是左操作数**
   4. 计算出结果后入栈
   5. 最后栈底元素即为所求

### 栈在递归中的应用

1. 递归的使用
   1. 注意递归表达式本身
   2. 注意递归的结束边界条件
2. 当进行递归时，把当前下一个执行语句呀入栈，递归结束后运行

### 队列在层次遍历的应用

1. 根节点入队
2. 队空，则结束遍历，否则执行语句三
3. 队列中节点出队，并访问孩子，先左后右，让其孩子入队，返回语句2

### 队列在计算机系统的应用

1. 主机和打印机速度不匹配时，打印机存在缓冲区以队列的形式
2. CPU处理器运算

## 数组和特殊矩阵

### 数组的定义

1. 数组是有N个相同类型数据元素构成的有限序列

### 数组的存储结构

1. 内存空间的计算
   1. LOC（Ai) = LOC(a0) + i*L;
   2. L为每个元素所占的储存单元
2. 多维数组内存空间
   1. LOC（Aij） = LOC(a00) + (i*(行+1)+j)*L,行优先
   2. 列优先，LOC（A00) + (j*(列+1)+i)*L

### 特殊矩阵的压缩存储

1. 对称矩阵
   1. 上三角区
   2. 下三角区
   3. 主对角线
   4. 元素下标对应关系
      1. k = (i-1)i/2 + j-1
      2. k = (j-1)j/2+i-1
2. 三角矩阵(默认行优先)
   1. 下三角矩阵定义
      1. 上三角矩阵都为常量，存储所有下三角和主对角线元素后存储上三角
      2. 位置
         1. 下三角，主对角线
            1. k = i(i-1)/2 +j-1
         2. 上三角
            1. n(n+1)/2
   2. 上三角矩阵
      1. 位置
         1. k = (2n-i+2)(i-1)/2 + (j-i)
         2. 下三角 n(n+1)/2
3. 三对角矩阵
   1. k = 2i+j-3;
   2. i = (k+1)/3+1的向下取整
4. 稀疏矩阵
   1. 三元组
      1. 存储行列，aij值
      2. 采用数组存储
      3. 采用十字链表存储
   2. 存储稀疏矩阵不仅保存三元组，还要保存稀疏矩阵行数，列数，非零元素个数

# 串

## 串的定义和实现

### 串的定义

1. 串是由零个或多个字符组成的有限序列
2. 子串：串中任意多个连续的字符组成的子序列称为该串的子串
3. 主串：包含子串的串

### 串的基本操作

1. StrAssign(&T,chars)，把串赋值为chars
2. StrCopy(&T,s)，将s串复制给T串
3. StrEmpty(S)，判空操作
4. Strcompare（S,T)判断S，T串的大小比较，S>T返回>0,=则返回 0 ,<则返回<0
5. StrLength(S)，求串长
6. SubString（&Sub,S,pos,len)求子串
7. Concat(&T,s1,s2) 串链接，将s1,和s2连接后放入T
8. Index（S,T)寻找S，中与T相同的子串，返回开始位置
9. ClearString（&S)，将字符串清为空串
10. DestroyString（&s),将字符串空间销毁

### 串的存储结构

1. 定长顺序存储
   1. 利用数组进行存储
2. 堆分配存储
   1. malloc堆空间存储
3. 块存储
   1. 是采用链表的形式，但是每个节点存储一个或者多个字符
   2. 最后一个节点占不满的时候存储#

## 串的模式匹配

### 简单的模式匹配算法

1. index
   1. 定位操作
   2. 设置双指针，如果匹配到不相等的字符
   3. 回溯i,j 
      1. i = i-j+2;返回的是主串的下一个匹配的位置
      2. j= 1;返回子串第一个匹配的位置、
   4. 满足条件返回i-T.length

### KMP算法

1. 求出next数组
   1. 默认next1,2为0,1
   2. 然后依次找之后的
   3. 通过移位进行匹配如果，上下对应匹配则，next【j】为已匹配的后一个字符位置
2. 找到next数组后
   1. 采用双指针
   2. 如果j == 0 或者 匹配成功
      1. 继续比较
   3. 匹配不成功
      1. j = next[j]
3. 成功后返回i-T.length

### KMP算法的优化

1. 主要是对next数组的优化
2. nextval数组的求法
   1. 先求出next数组
   2. 然后从左到右依次遍历
   3. 如果存在当前字符与next【j]字符相等时，修改为next【j]所对应的值

# 树与二叉树

## 树的基本概念

### 树的定义

1. 空树：当没有节点时
2. 根：有且仅有一个特定的节点为根
3. 子树：每个集合本身都可以分为m个不同的树
4. 特点：
   1. 树的根节点没有前驱，其他节点有且仅有一个前驱
   2. 数的所有节点有0或多个后继

### 基本术语

1. 祖先：从根到该节点的路径上的所有节点为该节点的祖先
2. 子孙：将该节点分离出去后形成的树内的节点为子孙
3. 双亲：到根节点最近的节点为该节点的双亲
4. 孩子
5. 兄弟，堂兄弟
6. 节点的层次
7. 节点的深度：节点所在的层次
8. 高度：节点的高度为以该节点为根的子树的高度
9. 树的高度：树中节点的最大层数
10. 节点的度：节点的孩子个数
11. 树的度：节点的最大度数
12. 分支节点：度不为0的节点
13. 叶子节点：度为0的节点
14. 有序树：各个子树之前存在顺序不可互换
15. 无序树
16. 路径：两个节点相连经过的路径
17. 路径长度：两个节点经过的边数
18. 森林：由m个互不相交的数形成的集合

### 树的性质

1. 树的节点数 = 所有节点的度数和+1
   1. 每个节点都有一个前驱，也就是一个入度，除了根
2. 度为M的树中的第i层最多由mi-1个节点
3. 高度为h的m二叉树至多有mh-1/m-1个节点
4. 度为m，具有n个节点的数的最小高度为logm（n(m-1)+1)的向上取整
5. 度为m，具有n个节点的数的最大高度为n-m+1

##  二叉树的概念

### 二叉树的定义及其主要特性

1. 空二叉树
2. 由一个根节点和两个互不相交的左右子树形成的，**左右子树有顺序之分**
3. 二叉树和度为2的树的区别
   1. 度为2的树最少为3个节点，二叉树可以为空
   2. 度为2的有序树的孩子左右次序是相对而言的，
4. **几种特殊的二叉树**
   1. 满二叉树
      1. 一颗高度为h，且有2h-1个节点的二叉树成为满二叉树
   2. 完全二叉树
      1. 当且仅当每个节点和满二叉树的节点编号一一对应
   3. 二叉排序树
      1. 左子树的所有节点的关键字均小于根节点的关键字
      2. 右子树的所有节点的关键字均大于根节点的关键字
      3. **左右子树又分别为二叉排序树**
   4. 平衡二叉树
      1. 树中的任意一个节点的左子树和右子树的高度之差不大于1
   5. 正则二叉树
      1. 每个分支节点都有两个孩子，只有度为0或2的节点
5. **二叉树的性质**
   1. 非空二叉树的叶子数等于度为2的节点数+1
      1. 节点数 = 分支总数+1
      2. 分支总数 = 度为1* 1+ 度为2*2
      3. 节点数 = 度为1+度为0+度为2
   2. 非空二叉树第k层最多为2k-1-1个节点
   3. 高度为h的二叉树最多有2h-1个节点
   4. 二叉树的个数
   5. $$
      C
      n
      =
      (2n)!/
      (n+1)!
      n!
      
      ​
      $$
   
6. 完全二叉树
   1. 最后一个分支节点编号为n/2的向下取整，小于这个为分支节点，大于为叶子节点
   2. 叶子节点只能出现在最后两层
   3. 度为1的节点最多只有一个，且只有左孩子，且该节点为最后一个分支节点
   4. 若n为奇数，则每个分支节点都有左右孩子（**只和最后一个分支节点有关**），偶数，最后一个只有左孩子
   5. i>1时，节点i的双亲为i/2的向下取整
   6. i有左右孩子时，左孩子为2i，右孩子为2i+1
   7. 节点i的深度为log2i向下取整+1
7. 具有n个节点的完全二叉树高度
   1. log2（n+1)的向上取整
   2. log2n的向下取整+1

### 二叉树的存储结构

1. 顺序存储
   1. 自上而下，自左而右
   2. 满二叉树和完全二叉树适合
2. 链式存储
   1. 含有n个节点ed二叉链表中，还有n+1个空指针域
   1. 二叉树一般采用链式存储

## 二叉树的遍历和线索二叉树

### 二叉树的遍历

1. 二叉树的遍历是按照某条路径访问树的各个节点
2. 先序遍历：根左右
3. 中序遍历：左根右
4. 后序遍历：左右根
5. 先序遍历
   1. 递归实现
   2. 先访问根节点
   3. 先序遍历左子树
   4. 先序遍历右子树
6. 中序遍历
   1. 递归实现
   2. 中序遍历左子树
   3. 访问根节点
   4. 中序遍历右子树
7. 后序遍历
   1. 递归实现
   2. 后序遍历左子树
   3. 访问根节点
   4. 后序遍历右子树
8. 层序遍历
   1. 采用队列的方式遍历
   2. 先判空
   3. 非空根节点入队
   4. 当队列非空
   5. 出队，并将出队节点的左右孩子入队（**如果存在**)
9. 遍历构造二叉树
   1. 先序遍历和中序遍历
      1. 先序确定根节点
      2. 中序通过根节点确定左右子树
   2. 后序遍历和中序遍历
      1. 后序确定根节点
      2. 中序通过根节点确定左右子树
   3. 层序遍历和中序遍历
      1. 层序确定根节点
      2. 中序同上

### 线索二叉树

1. 基本概念
   1. 根节点没有前驱
   2. 最后一个节点没有后继
   3. n个节点存在n+1个空指针域
   4. 线索链表
      1. 增加标志tag表示左右孩子表示含义
      2. 0表示孩子
      3. 1表示后继
2. 中序线索二叉树的构造
   1. 通过中序遍历实现
   2. 双指针
      1. pre表示前驱
      2. p表示当前节点
   3. 递归线索化左子树
   4. 线索化过程
      1. p的左孩子为空
      2. p的前驱为pre
      3. 修改标志位
      4. **如果pre不为空，且右孩子为空**
      5. pre节点的后继为p
      6. 修改标志位
      7. pre = p，修改pre指向
   5. 递归线索化右子树
   6. **每个遍历的最后一个节点的后继需要处理为NULL，并设置标志位**
3. 先序线索二叉树
   1. 与中序同理
   2. **在处理前驱时，需要判断其标志位是否存在左孩子，如果存在则进行左子树的线索化，否则不进行**
4. 后序线索化二叉树
   1. 与中序同理
5. 中序找后继
   1. 标志位1，右线索即为所求
   2. 标志位0，左子树的最左下的元素即为所求**while(p->tag == 0) p = p->lchild;**
6. 中序找前驱
   1. 标志位1，左线索即为所求
   2. 标志位0，右子树的最右下的元素即为所求**while(p->tag==0)p = p->rchild;**
7. 先序找后继
   1. 标志位1，右线索即为所求
   2. 标志位0，左孩子存在则为左孩子，反之为右孩子
8. 后序找前驱
   1. 标志位1，左线索即为所求
   2. 标志位0，右孩子存在则为右孩子，反之为左孩子

## 树，森林

### 树的存储结构

1. 双亲表示法
   1. 根节点下标为0，位置域为-1
   2. 其他节点的位置域为其父节点下标
2. 孩子表示法
   1. 每个链表节点为一个struct，包含孩子位置和下一个节点
   2. 每个数组元素包含数据和链表节点
   3. 节点存储数据后，若存在孩子则将其插入链表
3. 孩子兄弟表示法
   1. 存储数据和第一个孩子和右兄弟指针

### 树，森林，二叉树的转化

1. 树转化为二叉树
   1. 兄弟节点连成线
   2. 每个节点保留第一个孩子连线
   3. 旋转
2. 森林化二叉树
   1. 将每个树化为二叉树
   2. 每个树的根加一条线
   3. 旋转
3. 二叉树化森林

### 树和森林的遍历

1. **树的遍历**
   1. 先根遍历
      1. 先访问根
      2. 再依次访问所有子树
   2. 后根遍历
      1. 先依次访问所以子树
      2. 再访问根
2. **森林的遍历**
   1. 先序遍历
      1. 先访问第一个树根节点
      2. 先序遍历根的所有子树
      3. 依次遍历其他树
   2. 中序遍历
      1. 先中序遍历根的所有子树
      2. 访问树的根
      3. 依次中序遍历其他树
   3. 先根对应先序
   4. 后根对应中序

## 树和二叉树的应用

### 哈夫曼树和哈夫曼编码

1. 哈夫曼树的定义
   1. 权：树中节点被赋予的一个值
   2. 带权路径长度：路径长度乘以该节点的权值
   3. **树的带权路径长度**：所有节点的带权路径长度之和
   4. 哈夫曼树：路径之和最小的树
2. 哈夫曼·树的构造
   1. 将两个权值最小的作为新节点的左右子树
   2. 将最小的节点和刚才的新节点再作为新节点的左右子树
   3. 直到所以权值节点都被构造
3. 哈夫曼特点
   1. 每个权值节点都成为了叶子节点
   2. 新建n-1个节点
   3. 哈夫曼树不存在度为1的节点
4. 哈夫曼编码
   1. **变长编码**
   2. **定长编码**


### 并查集

1. 并查集的概念
   1. 一种简单的集合表示
   2. 基本操作
      1. Initial（S)，将集合中每一个元素都初始化为只有一个单元素的子集和
      2. Union（S,root1,root2）把集合S中的子集root2并入子集和root1，两个子集不能相交
      3. Find（S,x)查找集合S中单元数x所在的子集合，返回其根节点
2. 并查集的存储结构
   1. 并查集的根节点对应集合内元素的个数的负值
   2. 初始化的每个集合都为一棵树，每个值为-1
3. 并查集的实现优化
   1. 将节点数更少的集合并入节点数更多的树
   2. **比较根节点的大小，小的节点数更多**
4. 改进的FInd操作
   1. 先找到根
   2. 然后将寻找x路径上的所有经过的节点都直接挂在根上
   3. **用于缩小树的高度**

# 图

## 图的基本概念

### 图的定义

1. 定义
   1. 有顶点集和边集组成
   2. |V|表示顶点的个数，|E|表示边的个数
2. 有向图
   1. 若E是有向边，弧的有限集合，则称G为有向图，弧是顶点的有序对，记为<V,W>v,w是顶点，v称为弧尾，w称为弧头
3. 无向图
   1. 若E是无向边的有限集合，则称G为无向图，边是顶点的无序对，即为（v,w)或者（w,v），他们互为邻接点
4. 简单图，多重图
   1. 简单图
      1. 不存在重复边
      2. 不存在顶点到自身的边
   2. 多重图
      1. 两个顶点的边数大于一条
      2. 允许顶点通过一条边和自身联系
5. 顶点的度，入度，出度
   1. 表示依附于顶点的边数
   2. 无向图的度数等于边数的两倍
   3. 顶点的度等于入度和出度的和
   4. 有向图的入度和出度之和相同，并等于边数
6. 路径，路径长度，回路
   1. 一个顶点到另一个顶点路过的顶点序列，**包含这两个顶点**
   2. 路径上的边的数量为路径长度
   3. 如果第一个顶点和最后一个顶点相同表示图中存在环
7. 简单路径，简单回路
   1. 顶点不重复出现的路径，**简单路径**
   2. 除最后一个和第一个顶点外不重复出现的回路，**简单回路**
8. 距离
   1. 如果一个顶点到另一个顶点的最短路径存在，则称为两个顶点间的距离
   2. 反之为无穷
9. 子图
   1. 如果一个图的<V,E>是另一个图的<V,E>的子集，则称子图
   2. **生成子图**，
10. 连通，连通图，连通分量，**对于无向图**
    1. 路径存在则两点连通
    2. 如果每个顶点之间都是连通的，则称为连通图，反之为非连通图
    3. 无向图的极大（**连接尽可能多的边）**连通子图为连通分量
11. 强连通图，强连通分量，**对于有向图**
    1. 如果两个顶点互相存在路径，则两个顶点强连通
    2. 如果每个顶点都是强连通的，则此图为强连通图
12. 生成树，生成森林
    1. **连通图的生成树**是包含图中全部顶点的一个极小连通子图，无环的
    2. **如果图顶点为n，生成树的顶点个数为n-1**
    3. **非连通图的生成森林**
13. 边的权，网，带权路径长度
    1. 每条边具有某种含义的数值称为权值
    2. 边上带权的图称为带权图，也称网
    3. 路径上所有边的权值之和为带权路径长度
14. 完全图，
    1. **对于无向**
       1. 无向图的边数为0到n(n-1)/2,具有n(n-1)/2的无向图为完全图，即为任意两个顶点之间都存在边
    2. 对于有向
       1. 有向图的边数为0到n（n-1),具有n（n-1)的有向图为有向完全图
15. 稠密图，稀疏图
    1. 相对而言
    2. |E|<|V|log2|V|的时候为稀疏图，反之
16. 有向树
    1. 一个顶点的入度为0，其余顶点入度为1的有向图为有向树

## 图的存储及基本操作

### 邻接矩阵

1. 一个一维数组存储顶点信息，一个二位数组存放图中的边的信息
2. 如果两个顶点存在边，则设为1，反之为0
3. **对于网**，如果顶点边相连，则设为权值，不存在则设为0或者无穷
4. 时间复杂度
   1. 空间复杂度（|V|^2)
5. **特点**
   1. 无向图是一个对称矩阵
      1. 所以按照上下三角矩阵的方式进行存储
   2. 无向图的一行或者一列表示该点的度
   3. 有向图的一行表示出度数，一列表示入度数
6. 边数多的适合使用邻接矩阵

### 邻接表

1. 稀疏图适合使用邻接表
2. 邻接表与孩子兄弟表示法相同
3. 存在一个顶点表，内包含顶点值和第一个邻接边的指针
4. 存在一个边表，内包含与顶点相连的所有边，**链表形式存储**
5. 空间复杂
   1. 无向图（|V|+2|E|)
   2. 有向图（|V|+|E|)
6. **特点**
   1. 无向图的顶点度，邻接表的链表内的边表个数
   2. 邻接表不唯一

### 十字链表，**有向图**

1. **存储方式**
   1. 弧结点
      1. tailvex存放弧尾顶点，headvex存放弧头顶点
      2. hlink存放头顶点的边链表
      3. tlink存放弧尾节点的边链表
      4. info表示权值
   2. 顶点节点
      1. 数据值，
      2. firstin弧头的第一条弧
      3. first弧尾的第一条弧

### 邻接多重表

1. **存储方式**
   1. 边表
      1. ivex，jvex依附于边的两个顶点
      2. ilink，jlink表示边链表
   2. 顶点表
      1. 数据                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
      2. firstedeg 表示顶点的第一条边
2. 空间复杂度与十字链表都是（|V|+|E|)

### 图的基本操作

1. adjacent（G,x,y)判断图是否存在边x,y
2. Neighbors(G,x)列出图中与x相邻的边
3. InsertVertex(G,x)在图中插入顶点x
4. DeleteVertex（G,x)在图中删除顶点
5. AddEdge（G,x,y) 变不存在则添加边
6. RemoveEdge(G,x,y)边存在则删除边
7. FirstNeighbor(G,x) 找到下一个邻接点
8. NextNeighbor（G,x,y) 返回除了x外的邻接点，如果为x返回-1

## 图的遍历

### 广度优先搜索

1. 广度优先搜索类似于树的层序遍历
2. 首先访问顶点V,然后依次访问他的相邻节点，然后从访问过的节点出发，继续依次访问相邻节点，直至所有节点被访问
3. **算法思想**
   1. **邻接表实现广度优先搜索**
      1. 初始化一个队列（用于储存没有访问邻接点的顶点）
      2. 初始化一个数组，用于看顶点是否已经被访问
      3. 遍历数组，对没有访问过的元素进行广度搜索
      4. 广度优先搜索
         1. 访问该顶点
         2. 对顶点做标记，入队
         3. 循环遍历队列非空
            1. 访问队列队首节点
            2. 然后出队
            3. 循环遍历该节点的边表，找到所有临接点，如果该顶点没有背访问，标记访问后入队
      5. **、复杂度分析：** 
         （1）空间复杂度: 最坏情况，辅助队列大小为O(V) 。
         （2）对于邻接矩阵存储的图，访问个顶点需要O(V)的时间，查找每个顶点的邻接点都需要O(v) 的时间，而总共有个顶点，时间复杂度为O(V^2)。
         （3）对于邻接表存储的图，访问个顶点需要的时间O(V)，查找各个顶点的邻接点共需要的时间O(E)，时间复杂度为O(V+E)。
   2. **邻接矩阵实现广度优先搜索**
      1. 访问初始顶点
      2. 标记访问，入队
      3. 循环遍历非空队列
         1. 访问队首顶点，出队
         2. 检测该节点的所有临接点，没有被访问则标记访问后入队
   3. 广度优先搜索解决单源最短路径
      1. 初始化路径数组内每个顶点长度，无穷
      2. 访问初始顶点，初始顶点路径为0，顶点入队
      3. 循环遍历队列
      4. 出队顶点，访问顶点的邻接顶点
      5. 如果顶点没有被访问，则标记访问后，入队，**路径长度为出队节点的路径加1**
   4. 广度优先生成树

### 深度优先搜索

1. 深度优先搜索类似于树的先序遍历

2. 基本思想：先访问初始顶点，然后访问一个未被访问的邻接点，依次进行，直至该节点没有未被访问的邻接点，退回到最近的一个节点，继续搜索

3. 前提

   1. 标记数组，用于标记顶点是否被访问，初始化标记数组
   2. 遍历访问数组，对未访问的数组深度优先搜索

4. **邻接表实现深度优先搜索**

   1. 访问节点
   2. 节点标记访问
   3. 检查节点所有的临接点
   4. 如果该邻接点未被访问，对该节点进行深度搜索

5. **邻接矩阵实现深度优先搜索**

   1. 访问节点

   2. 节点访问标记

   3. 检查节点的所有临界点

   4. 如果该邻接点未被访问，对该邻接点进行深度搜索

      

6. **复杂度**

   1. 空间复杂度主要来自来⾃函数调⽤栈，最坏情况下递归深度为OV ；最好情况为O1。
   2. 对于邻接矩阵存储的图，访问个顶点需要O(V)的时间，查找每个顶点的邻接点都需要O(v) 的时间，而总共有个顶点，时间复杂度为O(V^2)。
   3. 对于邻接表存储的图，访问个顶点需要的时间O(V)，查找各个顶点的邻接点共需要的时间O(E)，时间复杂度为O(V+E)。

## 图的应用

### 最小生成树

1. 定义：包含权值最小的那颗生成树为最小生成树
2. 生成树：
   1. 包含所有顶点的极小连通子图
   2. 去一条边，为非连通图
   3. 加一条边，为环
3. **性质**
   1. 权值互不相等时，最小生成树唯一，相等时不唯一
   2. 最小生成树的权值之和是唯一的
   3. 边数等于顶点数减一
4. **最小生成树的构造**
   1. prim算法
      1. 初始时从图中选择任意一个顶点，然后选择与该顶点最近的一个顶点（权值最小边）
      2. 然后在顶点集合中选择权值最小的边（不能成环），连接
      3. 最后连接n-1条边
      4. **时间复杂度**
         1. O（V^2)
   2. **kruskal**算法
      1. 初始时有一个边集，和全部的顶点
      2. 循环按照边集的权值大小依次加入图中，将顶点连线
      3. **不能形成回路，形成则加入其他边**
      4. 直至连接n-1条边
      5. **时间复杂度**
         1. O（Elog2E)

### 最短路径

1. 定义：带权路径长度最小的那一条路径
2. Dijkstra算法
   1. 初始化：
      1. 设置一个集合S用于记录已经求得的最短路径的点
      2. final数组标记各个顶点是否已经找到最短路径
      3. dist[]数组用于记录原点到其他顶点当前的最短路径长度，初始值为弧长或者无穷
      4. path[]表示从原点到顶点之间的最短路径的前驱节点。
   2. 从顶点集合中选择从当前点出发的最短路径的一个顶点
   3. 修改当前节点出发到达任意节点的最短路径长度
   4. 重复2-3操作n-1次
3. **floyd算法**
   1. 初始化方阵，方阵包含每个顶点之间的路径长度
   2. 以Vk作为中间节点，如果A[i]j < A[i]k + A[k]j ,则更新节点的最短路径
   3. k从0开始依次进行检测，满足2则更新
   4. 经过n次检测后，方阵保存最短路径
4. 复杂度
   1. BFS：O(V^2), O(V+E)
   2. Djikstra :O(V^2)
   3. floyd: O(V^3)

### 有向无环图

1. 如果一个有向图中不存在环，则称为有向无环图，简称DAG图
2. **有向无环图表示表达式**

### 拓扑排序

1. AOV网：顶点表示活动，有向边表示Vi先于vj进行
2. 拓扑排序
   1. 每个顶点只出现一次
   2. 顶点A在序列中排在顶点B的前面，则在图中不存在从B到A的路径
3. 算法步骤
   1. 从AOV网中选择一个没有前驱的顶点输出
   2. 从网中删除该顶点和所有以他为起点的边
   3. 重复1,2知道当前的AOV网为空，或当前网中不存在无前驱的顶点为止，**后一种情况说明存在环**
4. 复杂度
   1. 邻接矩阵：O(V^2)
   2. 邻接表：O(V+E)
5. **DFS实现拓扑排序**
   1. 思想：若u是v的祖先，则调用DFS访问u之前，必然已经对v进行了DFS访问，祖先时间必然大于子孙结束时间
6. 逆拓扑排序
   1. 选择一个没有后继的顶点输出
   2. 删除所有以他为终点的边
   3. 重复直至aov网为空
7. **拓扑排序不唯一**

### 关键路径

1. AOE网：顶点表示事件，有向边表示活动，边的权值表示活动的时间
2. 性质
   1. 只有摸顶点的事件发生后，从该点出发的活动才能开始
   2. 只有某顶点的各有向边的活动都结束时，表示顶点的事件发生
3. **关键路径的性质**
   1. 事件Vk的最早发生时间
   2. 事件Vk的最迟发生时间
   3. 活动ai的最早开始时间
   4. 活动ai的最迟开始时间
   5. 一个活动ai的最迟开始时间和最早开始时间的差额
   6. 所有差额构成的路径即为关键路径

# 查找

## 查找的基本概念

1. 查找：在数据集合中找到满足某种条件的数据元素的过程称为查找
2. 查找表：用于查找的数据集合称为查找表
3. 静态查找表：只涉及查找操作
4. 关键字：数据元素中唯一标识某个数据项的值
5. 平均查找长度：每个元素的查找概率乘以查找次数的和

## 顺序查找和折半查找

### 顺序查找

1. 顺序查找也称线性查找
2. 一般线性表的查找
   1. 循环遍历
3. 有序线性表的查找
   1. 当查找元素小于或大于遍历元素（增序或降序），查找失败
   2. ASL
      1. 不成功 n/2+n/(n+1)

### 折半查找

1. 算法思想
   1. 当满足low<=high时
   2. 将key与中间位置元素比较
   3. 相等，即查找成功
   4. 大于则low = mid+1
   5. 小于则high = mid-1
2. 查找判定树
   1. 存在n+1个叶子节点，表示查找失败的情况
3. ASL
   1. log2（n+1)-1

### 分块查找

1. 分块查找也称索引顺序查找
2. 思想：将查找表分为若干字块，块内元素可以无序，块间元素有序（表示不同字块大小分明）
3. ASL，b块，s个
   1. (s^2+2s+n)/2s

## 树形查找

### 二叉排序树

1. 二叉排序树的定义
   1. 左子树非空，则左子树的所有节点小于根节点
   2. 右子树非空，则右子树的所有节点大于根节点
   3. 左右子树分别为一颗二叉排序树
2. 查找
   1. 非递归算法
      1. 当树不为空，且key不等于该节点的数据
      2. 如果大于则T = T->Rchild
      3. 如果小于，则T = T->Lchild
3. 插入
   1. 递归算法
      1. 如果树为空，则直接插入
      2. 如果key == 节点的值，（插入失败，不能相同元素）
      3. 如果key大于节点值
         1. 对右子树执行插入操作
      4. 如果key小于节点值
         1. 对左子树执行插入操作
4. 构造
   1. 初始化树为NULL
   2. 依次插入每一个节点，调用插入函数
5. 删除
   1. 如果为叶子节点，则直接删除
   2. 如果存在一颗左或右子树，则让子树代替父节点的位置
   3. 如果存在两棵树，则让该节点的前驱，或者后继代替根
      1. 前驱：左子树的最右下节点
      2. 后继：右子树的最左下节点
6. ASL
   1. 执行时间为O(log2n）

### 平衡二叉树

1. 概念：任意一个节点的左右子树的高度差都不大于1
2. 平衡因子：左右子树的高度差
3. 插入
   1. 前半部分与二叉排序树相同
   2. 插入节点后如果破坏了性质
      1. LL时：右单旋
      2. RR时：左单旋
      3. LR时：先左单旋，再右单旋
      4. RL时：先右单旋，再左单旋
4. 构造
   1. 按照二叉排序树性质插入，如果不平衡就按照插入旋转
5. 删除
   1. 先按照二叉排序树删除
   2. 删除造成的不平衡按照插入情况旋转
   3. 如果旋转造成祖先不平衡则继续旋转
6. ASL
   1. O(log2n)

### 红黑树

1. 定义
   1. 每个节点不是黑色就是红色
   2. 根节点是黑色的
   3. 叶子节点（NULL）也是黑色的
   4. 不存在两个相邻的红节点
   5. 对于每个节点，从该节点到任意一个叶节点的简单路径内，所包含的黑节点的数量相同
   6. **根叶黑，不红红，黑路同**
2. 性质
   1. 从根到叶节点的最长路径不大于最短路径的2倍
   2. 有n个节点的红黑树的高度小于2log2（n+1)
3. 插入
   1. 先二叉排序树
   2. 插入为根节点，染为黑色
   3. 插入为非根节点，染为红色
      1. 满足定义结束插入
      2. 不满足定义（**不满足不红红**）
         1. 黑叔
            1. LL：右单旋，父换爷（交换颜色），染色
            2. RR：左单旋，父换爷，染色
            3. LR：先左单旋，再右单旋，儿换爷，染色
            4. RL：先右单旋，在左单旋，儿换爷，染色
         2. 红叔
            1. 父叔爷换色，爷变为新节点
4. 删除
   1. 先二叉排序树查找，删除
   2. 无孩子直接删除
   3. 有一个左右孩子，左右孩子直接代替

## B树和B+树

### B树及其基本操作

1. 定义
   1. 树中每个节点至多有m个子树，至多有m-1个关键字
   2. 若为根节点，至少有2个子树，至少一个关键子
   3. 非根节点，至少有m/2向上取整个子树，m/2-1个关键字
   4. 非叶节点的结构
      1. 存在n个有序的关键字
      2. n+1个指针
   5. 所有叶节点都出现在同一层次
2. 性质
   1. 节点的孩子数等于节点的关键字数加一（与折半二叉树的原理相似）
   2. 没有关键字则B树为空，有关键字则子树个数必然大于等于2，子树个数 = 关键字+1
   3. 除根节点外的非叶节点至少有m/2向上取整个子树，m/2-1个关键字
   4. 关键字从左到右有序
3. **B树的查找**
   1. 在B树中找节点
   2. 在节点中找关键字
4. **B树的高度**
   1. h>logm（n+1）,每个树尽可能容纳更多关键子
   2. h<log [m/2] ((n+1/2)+1)，尽可能少的关键字
5. **B树的插入**
   1. 定位，先查找
   2. 插入
      1. 如果节点插入后关键字数量小于m，直接插入
      2. 如果插入后大于m，则需要分裂
         1. 在插入后的节点的中取中间位置的关键字，左部分关键放在新节点中
         2. 中间节点向上插入到父节点中，如果造成父节点超出
         3. 父节点继续分裂
6. **删除**
   1. 如果节点的关键字数大于m/2-1，直接删除关键字
   2. 如果兄弟够借
      1. 将父节点拉下取代删除的节点，然后让兄弟节点移位父节点
   3. 当左右兄弟的关键字都是m/2-1时，将关键字删除后让这两个兄弟已经他们中间的父关键字合并

### B+树

1. 基本概念
   1. 每个分支至多有m颗子树
   2. 非叶根节点至少有两颗子树，其他每个分支节点至少有m/2个子树
   3. **节点的子树个数和关键字个数相同**
   4. 所有也节点包含所有关键字，叶节点中将关键字按照大小顺序进行排列，相邻也节点也按照大小顺序排列
   5. 所有分支节点仅包含它的各个子节点
2. 差异
   1. B+树n个关键字对应n个树，B树n个关键字对应n+1个树
   2. 关键字范围一个需要减一，一个不需要
   3. B+树叶子节点包含所有关键字，非叶节点可以重复包含，在B树，叶子节点和非叶节点不重复包含
   4. B+树，叶子节点包含信息，非叶节点仅索引，B树，非叶节点和叶节点都包含信息

## 散列表

### 散列表的基本概念

1. 散列函数：一个把查找表中的关键字映射车好难过该关键字对应地址的函数
2. 散列表：根据关键字直接进行访问的数据结构

### 构造

1. 直接定址法
   1. 分布连续
   2. H（k）= a*k+b
2. 除留余数法
   1. H（k）= k%p
3. 数字分析法
   1. 适用于已知关键字
4. 平方取中法
   1. 取关键字的平方的中间几位作为散列地址

### 处理冲突

1. 开放地址法
   1. 线性探测法
      1. 发生冲突时，顺序探测表中下一个单元，（最后一个的下一个是第一个）
   2. 平方探测法
      1. 发生冲突时，依次探测1，-1,2，-2^2,3，-3^3
      2. 至少探测一半的单元
   3. 双散列法
      1. 两个散列函数，如果第一个冲突，则用第二个散列函数
      2. H = （H（k）+i*（H(k))）%m
   4. 伪随机序列
2. 拉链法
   1. 适用于经常插入删除
   2. 对于相同地址的进行插入链表操作

### 散列查找的性能分析

1. 三个因素
   1. 散列函数，处理冲突的方法，装填因子
   2. 装填因子： = 表中记录数/散列表长度

# 排序

## 排序的基本概念

### 排序的定义

1. 定义：重新排列表中元素
2. 稳定性：两个相同的元素在排序后相对位置不变
3. 内部排序
   1. 插入排序
      1. 直接插入排序
      2. 折半插入排序
      3. 希尔排序
   2. 交换排序
      1. 冒泡排序
      2. 快速排序
   3. 选择排序
      1. 简单选择排序
      2. 堆排序
   4. 基数排序
   5. 归并排序
   6. 计数排序
4. 外部排序
   1. 多路归并排序
   2. 败者树
   3. 置换选择排序
   4. 最佳归并树

## 插入排序

### 直接插入排序

1. 思想
   1. 查找出第i个元素在已排序表中位置
   2. 插入，将后面元素依次后移
2. 复杂度
   1. 时间
      1. 最好：On
      2. 最差：O n^2
   2. 空间
      1. O(1)

### 折半插入排序

1. 思想
   1. 在寻找将第i个元素插入到前面表的位置时使用折半查找
   2. 然后，将插入位置以后元素位置后移
   3. 插入元素
2. 复杂度
   1. 比较次数减少
   2. 时间：O（n^2)
   3. 空间：O（1）
3. 稳定

### 希尔排序

1. 思想
   1. 将表分为若干个子表（按照i，i+d，，，）d表示增量
   2. 然后对于每一个子表进行直接插入排序
   3. 当表的整体基本有序，对整个表进行插入排序
2. 复杂度
   1. 时间：约为O（n^1.3)，O(n^2)
   2. 空间：O（1）
3. 不稳定

## 交换排序

### 冒泡排序

1. 思想
   1. 从后往前，依次比较两个元素的大小
   2. 如果前一个元素大于后一个，则两个元素交换
   3. 然后一次排序后，找出最小一个值，放在有序数组之后
   4. 经过n-1趟排序后，一定有序
2. 复杂度
   1. 时间：O（n^2）
      1. 最少比较n-1,最少移动0
      2. 最多比较n（n-1)/2 ，最多移动，3n(n-1)/2
   2. 空间：O1
3. 稳定

### 快速排序

1. 思想
   1. 在待排序的表中任取一个元素作为pivot枢轴
   2. 划分
      1. 将元素中小于pivot的放在左边，大于的放在右边
   3. 然后将pivot放在空缺位置
   4. 然后对左右子表进行划分
   5. 直至左右子表元素都不可再划分
2. 复杂度
   1. 时间：最好：Olog2n
      1. 最坏 On^2
   2. 空间
      1. 最好：Olog2n
      2. 最坏：On
3. 不稳定

## 选择排序

### 简单选择排序

1. 思想
   1. 一共进行n-1趟
   2. 每次选出最小的元素放在已经有序的表的后面
   3. 直到最后一趟，表有序
2. 复杂度
   1. 时间：On^2
   2. 空间：O1
3. 不稳定

### 堆排序

1. 堆的定义
   1. 如果Li > L2i 且 Li > L(2i+1)，则称为大根堆
   2. 如果小于，则称为小跟堆
2. 思想
   1. 初始化建堆
   2. 然后输出堆顶元素
   3. 然后调整堆，继续输出堆顶元素
   4. 直至堆为空
3. 建堆
   1. 从前往后检测所有分支节点
   2. 如果不满足堆的要求
   3. 大根堆
      1. 对于根小于孩子的情况
      2. 根和比较大的孩子进行交换
   4. 小跟堆
      1. 根大于孩子
      2. 将根和比较小的孩子进行交换
   5. 然后继续向下，直至该树满足堆的定义
4. 复杂度
   1. 时间
      1. 建堆时间：On
      2. 调整时间：Oh
      3. 平均时间：Onlog2n
   2. 空间
      1. O1

## 归并排序，基数排序，计数排序

### 归并排序

1. 思想
   1. 二路归并
      1. 关键子视为n个有子表
      2. 然后两两归并，得到n/2个有1个或两个元素的有序表
      3. 然后对剩下的两两归并，直到合并成一个表
   2. 多路归并类似
2. 复杂度
   1. 时间 ：Onlog2n
   2. 空间：On
3. 稳定

### 基数排序

1. 思想
   1. 最高位优先法
   2. 最低位优先法
   3. 当长度为n的线性表中的关键子可以有d元组组成，可以用于基数排序
   4. 外部空间
      1. 需要一个长度为r的链队
   5. 分配
      1. 开始时，将链队置空
      2. 然后按照每个关键字的d元组中的权重最大的放入队列
      3. 然后将队列中每个队列的节点依次首尾相连（收集）
      4. 然后再按照比重次大的放入队列
      5. 然后再对其首尾相连（收集）
      6. 直至权重最小，收集后即为排序
2. 复杂度
   1. 空间
      1. Or
   2. 时间
      1. O（d(n+r))
      2. d表示关键子分成的d个元组
      3. n表示关键字的个数
      4. r表示基数
         1. 例：常数的基数可以为0-9
3. 稳定
4. 使用顺序和链式存储

### 计数排序

1. 思想
   1. 当所排序的元素的值较小时，可以使用
   2. 初始化计数数组
   3. 将数组中每个元素的出现次数记录
   4. 调整计数数组
      1. 将数组内元素改为小于等于该元素的个数
      2. c[i] = c[i] + c[i-1]
   5. 输出数组
      1. 输出数组，从后往前遍历输入数组
      2. B[c[A[i]]] = A[i];将计数数组内的输入数组元素位置-1赋值给输出数组
      3. 计数数组内c[a[i]]--; 
2. 复杂度
   1. 时间
      1. O（n+k)
      2. n为数组长度，k为数组内最大值的大小，也是外部空间的大小
   2. 空间
      1. O（n+k）
3. 稳定

## 外部排序

1. 总时间 = 内部排序时间+外部IO时间+内部归并时间

### 多路归并

1. 增加归并的路数，减少io的次数

### 败者树

1. 

### 置换选择排序

1. 

### 最佳归并树

1. 
