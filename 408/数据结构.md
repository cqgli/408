# 绪论

----

## 数据结构的基本概念

### 基本概念和术语

1. 数据：信息的载体
2. 数据元素：数据的基本单位，由若干个数据项组成
3. 数据对象：相同性质的数据元素的集合
4. 数据类型：一个值的集合和定义在此集合上的一组操作打的总称
   1. 原子类型：不可再分
   2. 结构类型：可以分成若干分的数据类型
   3. 抽象数据类型
5. 数据结构：相互存在一种或多种特定关系的数据元素的集合

### 数据结构三要素

1. 数据逻辑结构
   1. 集合
   2. 线性结构 一对一
   3. 树形结构 一对多
   4. 图状结构或网状结构 多对多
2. 数据的存储结构
   1. 顺序存储 
   2. 链式存储
   3. 索引存储
   4. 散列存储
3. 数据的运算

## 算法和算法评价

### 算法的基本概念

1. 五个特性
   1. 有穷性
   2. 确定性
   3. 可行性
   4. 输入
   5. 输出
2. 好算法标志
   1. 正确性
   2. 可读性
   3. 健壮性
   4. 高效性和低存储

### 算法效率的度量

1. 时间复杂度
   1. 大O表示法
2. 空间复杂度
   1. 大O表示法

# 线性表

_____

## 线性表的存储结构

### 顺序存储-顺序表

### 链式存储

1. 单链表
2. 双链表
3. 循环链表
4. 静态链表

## 线性表的定义和基本操作

### 线性表的定义

1. 线性表是具有相同数据类型·的n个数据元素的有限序列
2. 表头元素
3. 表尾元素
4. 特点
   1. 表中元素个数有限
   2. 表中元素具有逻辑上的顺序性，具有先后次序
   3. 元素都是数据元素，每个元素都是单个元素
   4. 每个元素都是相同的，每个元素所占的空间相同
   5. 元素具有抽象性
5. **线性表是一种逻辑结构，表示元素之间一对一的关系**
6. **顺序表和链表表示存储结构**

### 线性表的基本操作

1. InitList(&L)：初始化表
2. Length(L),：求表长
3. LocateElem(L,e) ; 按值查找
4. GetElem（L,i)按位查找
5. ListInsert(&L,e,i)在特定位置插入e
6. ListDelete(&L,i，&e)删除第i个位置的元素并将其值返回e
7. PrintList(L)：输出表
8. Empty(L) :判空
9. DestroyList(&L) ：销毁表

## 线性表的顺序表示

### 顺序表的定义

1. 线性表的顺序存储也称顺序表
2. 特点：表中元素的逻辑顺序和存储的物理顺序相同
3. 位序：从1开始，下标：从0开始
4. 优点：
   1. 可以随机访问，O1
   2. 存储密度高
5. 缺点：
   1. 删除和插入需要移动大量元素
   2. 顺序存储分配空间不灵活

### 顺序表的基本操作的实现

1. InitList(&L) ：静态顺序表的初始化
2. InitList(&L):动态顺序表的初始化
3. ListInsert(&L,i,e)：顺序表的插入
4. ListDelete(&L,i,&e)：顺序表的删除
5. LocateElem(L,e)：按值查找
6. LocateElem(L,i)按位查找

## 线性表的链式表示

## 单链表的定义

1. 线性表的链式储存也称单链表
2. 特点：非随机存取的存储结构
3. 头指针，头结点
4. 头结点的优点
   1. 第一个位置的节点和其他位置操作相同
   2. 无论链表是否为空，头指针都是指向头结点，空链表和非空表处理统一

### 单链表的基本操作

1. InitList(&L):单链表的初始化
2. Length(L):求表长
3. GetElem(L,i)返回序号为i的结点
4. LocateElem(L,e)返回值为e的节点
5. ListInsert(&L,i,e)在指定位置插入e
6. ListDelete(&L,i,&e)删除指定位置并返回e
7. List_HeadInsert(&L)头插法建立单链表
8. List_TailInsert(&L)尾插法建立单链表

### 双链表

1. 双链表的插入
2. 删除

### 循环链表

1. 循环单链表
   1. 设置尾指针表头表尾插入操作为O1
   2. 设置头指针表头插入为O1，表尾插入为On
   3. 尾指针的next为头指针
2. 循环双链表
   1. 头结点prior指向表尾节点
   2. 尾节点的next指向头结点
   3. 当为空表是头结点的prior和next都指向L
3. 静态链表
   1. 采用数组的描述链式存储

## 顺序表和链表的比较

1. 存储方式
   1. 一个既可以顺序存取，又可以随机存取
   2. 链表只能顺序存取
2. 逻辑结构和物理结构
   1. 顺序表的逻辑和物理位置有关系
   2. 链表的逻辑和物理位置没有关系
3. 查找删除插入操作
   1. 按值查找：
      1. 顺序表无序时，均为On
      2. 有序是顺序表为O(log2n)
   2. 按位查找
      1. 顺序表O1
      2. 链表On
   3. 插入删除
      1. 顺序表需要移动元素
      2. 链表不需要
   4. 空间分配
      1. 不知道存储规模的时候可以使用链表
      2. 当按序访问多的时候优先顺序表
      3. 当插入删除多的时候优先链表

# 栈，队列，数组

## 栈

### 栈的基本概念

1. 栈的定义
   1. 只允许在一端进行插入删除操作的线性表。
   2. 栈顶：线性表允许插入删除的一端
   3. 栈底：不允许插入删除的一端
   4. 空栈：不含任何元素
2. 栈的基本操作
   1. InitStack（&S);初始化一个空栈
   2. StackEmpty（S);判断一个栈是否为空
   3. Push(&S,x)：入栈，**先判断栈满**,
   4. Pop(&S,&x)，出栈，**先判断栈空**，将出栈元素赋值给x
   5. GetTop（S,&X),获取栈顶元素，**先判断栈空**,赋值给x
   6. DestroyStack（&s) ，销毁栈，释放S占用空间，**当为动态栈的时候，可以释放，静态自动释放，设置top = -1**
3. 当n个不同元素入栈的时候，出栈的不同排列顺序由1/n+1Cn,2n  个，为卡特兰公式

### 栈的顺序存储结构

1. 顺序栈的实现
2. 顺序栈的基本操作
   1. 初始化
   2. 判空，判满
   3. 出入栈
   4. 获取栈顶元素
   5. 销毁
3. 共享栈
   1. 开始都指向栈顶元素top0 = -1，top1 = maxsize，**两个判空条件**
   2. 当top0+1 == top1 时，判断栈满
   3. 0栈，先++ ，后入栈，1栈，先--，后入栈
   4. 0栈，先出栈，再--，1栈，先出栈，再++；

### 链栈

1. **带头结点**
2. **带头指针**
3. **带尾指针**
4. **带尾节点**

## 队列

### 队列的基本概念

1. 队列的定义
   1. 只允许在表的一端进行出队或者离队
   2. 队头：允许删除一端
   3. 队尾：允许插入一端
   4. 空队列：不含任何元素的空表
2. 常见基本操作
   1. InitQueue（&Q)，初始化队列，构建空队
   2. QueueEmpty(Q);判断队空
   3. EnQueue(&Q,x)，向一个队列中加入x，**先判断队满**
   4. DeQueue（&Q,&x)，删除队头元素，并赋值给x，**先判断队空**
   5. GetHead（Q,&x),获取队首元素，**先判断队空**

### 队列的顺序存储

1. 队列的顺序存储
   1. 队空条件
      1. Q.front == Q.rear == 0
   2. 入队
      1. 先赋值，队尾++
   3. 出队
      1. 先取值，队头++
2. **循环队列** 
   1. 判断空
      1. Q.rear == Q.front
   2. 判满（**舍弃一个储存空间**)
      1. (Q.rear+1)%maxsize == Q.front;
   3. **长度**
      1. 可以理解为队头往右然后到最后，在从开头到队尾的长度
      2. （Q.rear-Q.front+maxsize）%maxsize
   4. 入队
      1. 先判满
      2. 队尾+1模%maxsize
   5. 出队
      1. 先判空
      2. 队头+1%maxsize

### 队列的链式存储

1. 队列的链式存储
2. 判空（默认存在头结点）
   1. Q.front == Q.rear == NULL
3. 初始化
4. 入队
   1. 先判断是否为第一个节点
      1. 是则将Q.front->next = s;
   2. Q.rear->next = s
   3. s.next = NULL;
   4. Q.rear = s;
5. 出队
   1. 判空
   2. L = Q.front->next;
   3. Q.front->next = L->next;
   4. 判断是否为最后一个节点
      1. 是则Q.rear = NULL;
   5. free(L)；

### 双端队列

1. 输入输出受限
2. 两端的输入输出受限的各种形式

## 栈和队列的应用

### 栈在括号匹配的应用

1. 初始化空栈
2. 如果是左括号就入栈
3. 如果是右括号，就出栈，匹配则继续，**栈空时则不匹配**

### 栈在表达式求值的应用

1. 算术表达式
2. 中缀表达式转后缀表达式
   1. 初始化栈
   2. 操作数直接进如数组
   3. 当左括号时，直接入栈，右括号时，依次弹出左右括号之间的运算符
   4. 当遇到运算符，判断站内运算符，优先级大于等于该运算符的运算符弹出
   5. 压入该运算符
3. 后缀表达式求值
   1. 初始化栈
   2. 操作数入栈
   3. 遇到运算符取两个操作数，**先取出的是右操作数，后取出的是左操作数**
   4. 计算出结果后入栈
   5. 最后栈底元素即为所求

### 栈在递归中的应用

1. 递归的使用
   1. 注意递归表达式本身
   2. 注意递归的结束边界条件
2. 当进行递归时，把当前下一个执行语句呀入栈，递归结束后运行

### 队列在层次遍历的应用

1. 根节点入队
2. 队空，则结束遍历，否则执行语句三
3. 队列中节点出队，并访问孩子，先左后右，让其孩子入队，返回语句2

### 队列在计算机系统的应用

1. 主机和打印机速度不匹配时，打印机存在缓冲区以队列的形式
2. CPU处理器运算

## 数组和特殊矩阵

### 数组的定义

1. 数组是有N个相同类型数据元素构成的有限序列

### 数组的存储结构

1. 内存空间的计算
   1. LOC（Ai) = LOC(a0) + i*L;
   2. L为每个元素所占的储存单元
2. 多维数组内存空间
   1. LOC（Aij） = LOC(a00) + (i*(行+1)+j)*L,行优先
   2. 列优先，LOC（A00) + (j*(列+1)+i)*L

### 特殊矩阵的压缩存储

1. 对称矩阵
   1. 上三角区
   2. 下三角区
   3. 主对角线
   4. 元素下标对应关系
      1. k = (i-1)i/2 + j-1
      2. k = (j-1)j/2+i-1
2. 三角矩阵(默认行优先)
   1. 下三角矩阵定义
      1. 上三角矩阵都为常量，存储所有下三角和主对角线元素后存储上三角
      2. 位置
         1. 下三角，主对角线
            1. k = i(i-1)/2 +j-1
         2. 上三角
            1. n(n+1)/2
   2. 上三角矩阵
      1. 位置
         1. k = (2n-i+2)(i-1)/2 + (j-i)
         2. 下三角 n(n+1)/2
3. 三对角矩阵
   1. k = 2i+j-3;
   2. i = (k+1)/3+1的向下取整
4. 稀疏矩阵
   1. 三元组
      1. 存储行列，aij值
      2. 采用数组存储
      3. 采用十字链表存储
   2. 存储稀疏矩阵不仅保存三元组，还要保存稀疏矩阵行数，列数，非零元素个数

# 串

## 串的定义和实现

### 串的定义

1. 串是由零个或多个字符组成的有限序列
2. 子串：串中任意多个连续的字符组成的子序列称为该串的子串
3. 主串：包含子串的串

### 串的基本操作

1. StrAssign(&T,chars)，把串赋值为chars
2. StrCopy(&T,s)，将s串复制给T串
3. StrEmpty(S)，判空操作
4. Strcompare（S,T)判断S，T串的大小比较，S>T返回>0,=则返回 0 ,<则返回<0
5. StrLength(S)，求串长
6. SubString（&Sub,S,pos,len)求子串
7. Concat(&T,s1,s2) 串链接，将s1,和s2连接后放入T
8. Index（S,T)寻找S，中与T相同的子串，返回开始位置
9. ClearString（&S)，将字符串清为空串
10. DestroyString（&s),将字符串空间销毁

### 串的存储结构

1. 定长顺序存储
   1. 利用数组进行存储
2. 堆分配存储
   1. malloc堆空间存储
3. 块存储
   1. 是采用链表的形式，但是每个节点存储一个或者多个字符
   2. 最后一个节点占不满的时候存储#

## 串的模式匹配

### 简单的模式匹配算法

1. index
   1. 定位操作
   2. 设置双指针，如果匹配到不相等的字符
   3. 回溯i,j 
      1. i = i-j+2;返回的是主串的下一个匹配的位置
      2. j= 1;返回子串第一个匹配的位置、
   4. 满足条件返回i-T.length

### KMP算法

1. 求出next数组
   1. 默认next1,2为0,1
   2. 然后依次找之后的
   3. 通过移位进行匹配如果，上下对应匹配则，next【j】为已匹配的后一个字符位置
2. 找到next数组后
   1. 采用双指针
   2. 如果j == 0 或者 匹配成功
      1. 继续比较
   3. 匹配不成功
      1. j = next[j]
3. 成功后返回i-T.length

### KMP算法的优化

1. 主要是对next数组的优化
2. nextval数组的求法
   1. 先求出next数组
   2. 然后从左到右依次遍历
   3. 如果存在当前字符与next【j]字符相等时，修改为next【j]所对应的值
3. 