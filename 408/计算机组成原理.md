# 计算机系统概述

## 计算机发展历程

1. 第一代：电子管
2. 第二代：晶体管
3. 第三代：中小规模集成电路
4. 第四代：大规模，超大规模集成电路

## 计算机系统层次结构

#### 计算机系统组成

1. 硬件系统
2. 软件系统

#### 计算机硬件

1. 冯若依曼计算机特点
   1. 采用存储程序的工作方式
   2. 硬件系统有运算器，存储器，控制器，输入设备，输出设备组成
   3. 指令和数据以同等地位存储在存储器
   4. 指令和数据都以二进制的形式存储
   5. 指令有操作码和地址码组成
2. 计算机的功能部件
   1. 输入设备
   2. 输出设备
   3. 存储器
      1. 分为主存储器（内存），辅助存储器（外存）
      2. MAR：储存器地址寄存器
         1. 用于存放访问地址，经过地址译码后找到所选存储单元
         2. 反应了存储单元的个数
      3. MDR：存储器数据寄存器
         1. 用于按存储单元的地址存取
         2. 等于存储字长
   4. 运算器
      1. 累加器：ACC
      2. 乘商寄存器：MQ
      3. 操作数寄存器：X
      4. 变址寄存器：IX
      5. 基址集训期：BR
      6. 算术逻辑单元：ALU
   5. 控制器
      1. 计数器：PC
      2. 指令寄存器：IR
      3. 控制单元：CU

#### 计算机软件

1. 系统软件和应用软件
2. 三个级别的语言
   1. 机器语言:二进制代码语言
   2. 汇编语言
   3. 高级语言
   4. 汇编程序:将汇编语言翻译为机器语言
   5. 解释程序：**将源程序的语句逐条翻译为机器指令并立即执行**
   6. 编译程序：将高级语言翻译为汇编或机器语言
3. 
4. 软件和硬件的逻辑等价性
   1. 对于某一功能既可以使用软件进行实现，也可以硬件实现

#### 计算机系统的层次结构

1. 微程序机器层
2. 传统机器语言层
3. 操作系统层
4. 汇编语言层
5. 高级语言层
6. ISA：指令体系结构

#### 计算机系统的工作原理

1. 存储程序的工作方式
   1. 取指令
      1. PC-MAR-M-MDR-IR
   2. 分析指令
      1. OP（IR）-CU
   3. 执行指令
      1. Ad(IR)-MAR-M-MDR-ACC
2. 从源程序到可执行文件
   1. 预处理器cpp：预处理，得到.i文件
   2. 编译器ccl：编译,等到.s文件，汇编语言
   3. 汇编器as：汇编，得到.o文件，机器语言
   4. 链接器ld：得到可执行文件.exe

## 计算机的性能指标

#### 计算机的主要性能指标

1. 机器字长

   1. 计算一次整数运算所能处理的二进制的位数
   2. 等于通用寄存器的位数和ALU的宽度

2. 数据通路带宽

   1. 总线一次能够并行传输的信息的位数

3. 主存容量

   1. 主存储器的最大容量
   2. 等于MAR*MDR

4. 运算速度

   1. 吞吐量和响应时间
      1. 吞吐量：系统在单位时间内处理请求的数量
      2. 响应时间：用户发送请求，计算做出响应并取得结果的时间
   2. 主频和cpu时钟周期
      1. cpu时钟周期
         1. 机器内部主时钟脉冲信号的宽度，**cpu的最小工作时间**
      2. 主频
         1. 机器内部主时钟的频率，**时钟周期的倒数**
      3. CPI：执行一条指令所用的时钟周期数
      4. IPS：每秒执行ed指令数，**主频/平均CPI**
      5. cpu执行时间
         1. **时钟周期数/主频=（指令条数*CPI）/主频**
      6. 性能：**主频，CPI，指令条数**
      7. MIPS
      8. FLOPS

5. 基准程序


# 数据的表示和运算

## 数制和编码

#### 进位计数制及其相互转换

1. 进位计数制
   1. 常见：二进制，十进制，八进制，十六进制
   2. 基数：表示某一位上的数字
   3. 位权：表示某一位所占的进制次方数
2. 进制互换
   1. 二转八，十六
      1. 3位合一
      2. 4位合一
   2. 转十进制
      1. 数码和权值的乘积和
   3. 十进制转二进制
      1. 除基取余法
         1. 先得到的是低位，最后为高位
      2. 乘积取余法

#### 定点数的编码表示

1. 真值和机器数
   1. 真值：带有正负号的值
   2. 机器数：把正负号变为0和1的数
2. 机器数的定点表示
   1. 定点表示，浮点表示
   2. 计算机中常用
      1. 补码表示整数
      2. 原码表示浮点数的尾数部分
      3. 移码表示浮点数的阶数部分
   3. 定点小数
   4. 定点整数
3. **原码，反码，补码，移码**
   1. 原码
      1. 最高位表示符号，其余各位表示数的绝对值
      2. 字长为n+1时，整数范围-（2^n- 1) <= x <= 2^n -1
      3. 特点
         1. 真值转换简单
         2. 乘除实现简单
         3. 0的表示不唯一，存在两中表示
         4. 加减复杂
   2. 补码
      1. 正数补码等于原码，负数补码等于数值位取反+1
      2. 字长为n+1时，整数范围-2^n <= x <= 2^n-1
      3. 特殊补码
         1. 0补等于-0补，全为0
         2. -1补等于全为1
         3. 2^n-1补为 011111
         4. -2^n的补为 10000
      4. 补码和真值的转换
         1. 正数补码等于原码
         2. 负数时，符号位变1，数值位按位取反+1
         3. 补码转换真值
            1. 正数一样
            2. 负数，变符号位，数制等于按位取反+1
         4. 补码和原码的负数可以通过符号位不变，数值位按位取反+1，互相转换。
   3. 反码
      1. 等于符号位不变，数值位按位取反
      2. 0的表示不唯一
      3. 表示范围少一个-2^n相比补码
   4. 移码
      1. 常用于表示浮点数的阶数
      2. 移码 = 补码+偏移量（ 例：1000,0000）
      3. 机器字长为n+1时，表示-2^n <= x< 2^n
      4. 特点
         1. 0的表示唯一
         2. **浮点数的移码**：是阶码的实际值加上偏移量（Bias）
         3. 整数的移码：**补码和移码可以通过变换符号位互相转换**
         4. 移码保留了原有数据的大小，移码大则真值大，反之亦然
   5. 特点
      1. 原反补，符号位相同，正数都相同
      2. 原，反数轴上对称
      3. 补码，移码数轴不对称，有唯一0，

#### 整数的表示

1. 无符号整数
   1. 全为数值位，没有符号位
   2. 机器字长为n时，表示范围0-2^n-1
2. 有符号整数
   1. 符号位在最前
   2. 常用补码表示
      1. 优势
         1. 0唯一
         2. 多表示一个数
         3. 符号位可以和数值位一起运算

#### C语言中的整数类型和类型转换

1. C语言的整数数据类型
   1. short,int,long
   2. un short,un int ,un long
   3. char
   4. 都是用补码存储
2. 有符号数和无符号数的转换
   1. 转换后的所有位置不变，但是符号位的解释改变
3. 不同字长整数的转换
   1. 小转大
      1. 原数字为无符号：高位补充0
      2. 原数字为有符号：进行符号位扩展
   2. 大转小
      1. 高位删除，低位直接赋值

## 运算方法和运算电路

#### 基本运算部件

1. 一位全加器
   1. 全加器（FA）：最基本的加法单元
   2. 和表达式：Si = Ai 异或 Bi异或 Ci-1
   3. 进位表达式：Ci = AiBi + (Ai异或 Bi)Ci-1
2. 串行进位加法器
   1. 二进制和：S = SnSn-1……S1
3. 并行进位加法器
   1. 通过已知的直接求出所有进位的值
   2. 递推公式
4. 带标志加法器
   1. 有符号溢出标志：OF  = Cn异或Cn-1，通过最后两位的进位可以判断
   2. 有符号正负标志：SF = Fn-1，即为第一位的0或1表示正负
   3. 零标志位：ZF = 1表示结果为0，反之不为0
   4. 无符号溢出标志：CF = Cout 异或 Cin ,可以通过输出进位，输入进位判断
5. 算数逻辑单元ALU
   1. 包含两个输入端，一个操作控制端ALUop，四个标志位，一个加法输出结果，一个输入进位和输出进位

#### 定点数的移位运算

1. 逻辑移位
   1. 左移，高位移出，低位补0,
   2. 右移，低位移出，高位补0
   3. **无符号整数左移，高位1移出则发生溢出**
      1. 例：假设有一个8位无符号整数`10000000`（十进制的128），左移1位后会变成`00000000`（因为最高位的1被移出了存储范围），但实际上，正确的数学结果应该是256，但8位无符号整数无法表示256，因此发生了溢出。
2. 算术移位
   1. 将操作数视为有符号数
   2. 左移，高位移出，低位补0，如果，移位后的最高位不同于原来的，则发生溢出
   3. 右移，低位溢出，高位补0，如果，低位是1时，移出影响精度

#### 定点数的加减运算

1. 补码的加减法运算
   1. 运算特点
      1. 逢二进一
      2. 加法直接加，减法，被减数加上减数的负数的补码
      3. 符号位数值位一起加，符号位也直接得出
      4. 高位丢弃
   2. 补码的负数：**补码按位取反+1**
2. 溢出的判断
   1. 两个正数或者两个负数相加时会发生溢出
   2. 一位符号位
      1. 符号位表示As，Bs
      2. V = AsBs非Ss + 非（AsBs）Ss,即为当两个符号都为1时且相加符号位不为1，两个符号位都为0，相加符号位为1,时溢出
   3. 双符号位
      1. 表示00，结果为正数，无溢出
      2. 表示01，结果为正溢出
      3. 表示11，结果为负数，无溢出
      4. 表示10，结果为负数，负溢出
      5. V = Ss1异或Ss2，即为两个符号位不同时溢出
   4. 一符号位根据数值位的进位判断溢出
      1. V = Cn 异或 Cn-1,同OF的表达
3. 加减运算电路
   1. 组成
      1. 两个输入端，被加数接多路选择器（用于判断，加减法，加法直接加，减法，变为补码的负数加）
      2. sub，控制信号
      3. CIn，Cout输入输出进位
      4. 加法器
      5. 四个标志位和结果
   2. 无符号数的大小比较
      1. ZF等于1，A=B,表示相减为0
      2. ZF为0，CF=1，则A<B
      3. ~,CF = 0,则A>B
   3. 有符号的大小比较
      1. ZF =1 ,A等于B
      2. ZF = 0，SF = 1，OF为1时，表示正-负导致溢出，A>B
      3. ~，SF = 0，OF = 0，表示正减正，且A>B
      4. ~，SF = 1，OF = 0，A<B
      5. ~,SF =0 , OF= 1 ,表示负减正溢出，A<B
      6. **SF == OF则A>B,反之小于**
4. 原码的加减法
   1. 加法
      1. 同号求和，异号求差
   2. 减法
      1. 减号符号位取反，加法求和

#### 定点数的乘除运算

1. 定点数的乘法运算

   1. 原码乘法
      1. 符号位为原来两个符号位异或
      2. 数值位为两个乘数的绝对值之积
      3. 过程
         1. n次加法，n次移位
         2. 被乘数与乘数都以绝对值相乘
         3. 部分积PI表示乘法运算的中间结果
         4. Pi = 2^-1（Pi-1 + XYn-i)
            1. 2-1表示将结果右移一位
            2. X为被乘数，Y为乘数
            3. n-i表示的进行的第几轮，Y的第几位
   2. 补码乘法
      1. 过程
         1. n次加法，移位
         2. 每次加法的加数
            1. 辅助位-MQ最后一位 = 0，加0
            2. 等于1 ，加X补
            3. 等于-1，加-X补
         3. **辅助位，开始为0，可以每次右移后改变为MQ的最后一位**
         4. MQ的最后一位表示Yn-i
   3. 乘法电路
      1. 组成
         1. 被乘数寄存器：X
         2. 乘积寄存器：P（部分积）
         3. 乘积寄存器：Y
         4. C:进位
         5. 控制逻辑计数器：Cn
         6. 每次乘积完成后将CPY右移，低位舍弃

2. 除法运算

   1. 恢复余数法

      1. 符号位单独处理，两个异或
      2. 默认先上一，如果相减后为负数，则上0,，并将余数恢复
      3. 上0，则ACC+除数，一次加法后，ACC，MQ整体左移，ACC高位丢弃，低位补0
      4. 最后得到的商的位数等于机器字长

   2. 加减交替法

      1. 如果余数为负，则直接商0，让余数左移一位再加上除数得到新余数
      2. 余数为正，则让余数左移1一位，再减去除数得到新余数

   3. 定点小数的除法**规定被除数小于除数**

   4. 补码的除法运算

      1. 加减交替法
         1. 符号位参与运算
         2. 被除数，余数，除数采用双符号位
         3. 被除数和除数同号，则被输出减去除数，异号则加上除数
         4. 余数和除数同号则，上1，余数左移一位再减去除数
         5. 余数和除数异号，上0，余数左移一位，再加上除数
         6. 重复n次
         7. 末尾商恒为1

   5. 除法运算电路

      1. 组成

         1. 除数寄存器

         2. 余数寄存器

         3. 余数，商寄存器

         4. 逻辑控制器


## 浮点数的表示和运算

#### 浮点数的表示

1. 浮点数的表示格式
   1. N = （-1)s* M * R^E
   2. s表示正负，M为一个二进制的定点小数
   3. R为基数（进制），E为阶码或指数
2. 浮点数的表示范围
   1. 浮点数原码关于原点对称
   2. -（1-2^-24)*2^63~-2^24\*2^-64  2^-24\*2^-64 ~ (1-2^-24)\*2^63
   3. 大于正整数为正上溢出，小于最小负数为负上溢
   4. 正下溢，负下溢，通常表示为0
3. 浮点数的格式化
   1. 左规：尾数最高位不是有效位，尾数每左移一位，阶码减一
   2. 右规：尾数的大小绝对值应该大于1/2小于1，尾数每右移一位，阶码加一，可能导致溢出
4. IEEE 754标准
   1. 32位 1 8 23
   2. 64位 1 11 52
   3. 分别表示1为符号位，阶码，尾数
   4. 754的标准下尾数为大于1小于2
   5. **隐藏位：尾数的第一位一定为1，但是一般隐藏**
   6. 阶码 = 真值+偏置值
   7. **表示范围**
      1. 阶码e范围：1-254（32位）,1-2046(64位)
      2. 最小值为e = 1,尾数为0，则最小值为1*2^e-127,最大值为e = 254,尾数为1-2^-23，最大值为（2-2^-23)\*2^127
      3. 同理可知64位
   8. 特殊表示
      1. 正负0，符号位不同，其他全为0
      2. 正负无穷，符号位不同，阶码最大，尾数为0
      3. 无定义数，符号位不同，阶码全1，尾数不为0
      4. 非规格化正负数，符号位不同，阶码为0，值为正负2^-126* ( 0.f),:用于处理阶码下溢
   9. 定点和浮点的表示区别
      1. 数值的表示范围
      2. 精度
         1. 浮点数的精度降低了
      3. 数的运算
         1. 运算复杂
      4. 溢出问题

#### 浮点数的加减运算

1. 对阶
   1. 将两个操作数的小数点位置对齐，阶码相等，用小阶码向大阶码看齐的方式进行**尾数右移产生的低位不要移出，保留参加运算**
2. 尾数加减
   1. 将尾数加上隐藏位后一起进行加减运算
3. 对尾数重新规格化
4. 舍入
   1. 就近舍入，将尾数舍入为最近的值，如果距离一样，则舍入为偶数的值
   2. 正项舍入，将尾数向增长的方向舍入
   3. 负项舍入，将尾数向减小的方向舍入
   4. 截断法，直接截取所需要的位数
5. 溢出判断
   1. 如果正指数大于了最大值，则发生指数上溢
   2. 如果一个负指数小于了最小值，则发生指数下溢
   3. 右规导致指数上溢
   4. 左规导致指数下溢

#### C语言中的浮点数类型

1. 不同类型元素混合运算遵循的原则为整形提升
2. int 转float 需要舍入处理，影响精度
3. int float 转double，不影响
4. double，可能发生溢出，也可能舍入
5. float double，可能溢出，舍入

#### 数据的大小端和对齐存储

1. 数据的大端和小端方式存储
   1. 大端：高位存高位，低位存低位
   2. 小端：高位存低位，低位存高位
2. 数据按照边界对齐的方式存储
   1. 按照字进行存储
   2. 不按照

# 存储系统

## 存储器概述

#### 存储器的分类

1. 按计算机中的作用分类
   1. 主存储器：内存
   2. 辅助存储器：外存
   3. 高速缓冲存储器：cache
2. 存储介质分类
   1. 磁表面存储器：磁盘，磁带，
   2. 磁芯存储器
   3. 半导体存储器（MOS型和双极型）
   4. 光存储器：光盘
3. 按存取方式分类
   1. 随机存储器：RAM，静态RAM（DRAM），动态RAM（SRAM）
   2. 只读存储器：非易失性存储器，断电内容保留，随机读取
   3. 串行访问存储器：读取时按照物理位置先后寻址，包括顺序存取（磁带），直接存取（磁盘，光盘）
   4. 顺序存取：存储速度慢
   5. ​	直接存取：介于顺序和随机之间，先找某个区域，再区域内顺序找
4. 按信息可保存分类
   1. 易失性存储器：RAM
   2. 非易失性存储器：ROM，磁表面存储器，光存储器

#### 存储器的性能指标

1. 存储容量： = 存储字树*字长 = MAR\*MDR
2. 单位成本 ： 位价 = 总成本/总容量
3. 存储速度：数据传输速率 = 数据宽度/存取周期
   1. 存取时间：启动存储器开始到结束的时间，读出时间和写入时间
   2. 存取周期：一次完整读写操作的全部时间，连续两次独立访问存储器的最短间隔
   3. 主存带宽：每秒从主存进出的信息的最大数量

#### 多级层次的存储系统

1. 主要思想：上一层的存储器为低一层存储器的高速缓存
2. 主要体现在：cache-主存和主存-辅存
3. 主存和cache之间的数据都是透明的，主存和辅存之间的数据对于应用程序员是透明的

## 主存储器

#### SRAM芯片和DRAM芯片

1. SRAM的工作原理
   1. 静态随机存储器，双稳态触发器，非破坏性读出
   2. 特点：存取速度快，集成度低，功耗大，价格昂贵
2. DRAM工作原理
   1. 动态碎金存储器，通过栅极电容的电荷存储信息
   2. 特点：存取速度慢，集成度高，位价低，功耗小，需要定时刷新
   3. 刷新周期
      1. 集中刷新：利用一段时间对存储器的所有区域再生，这段时间存储器的读写禁止，死时间
      2. 分散刷新：将工作周期分为两部分，前半部分读写，后半部分刷新，增加了周期，但是没有死区
      3. 异步刷新：每个刷新周期只刷新一行，每隔刷新周期/行数的刷新时间间隔t
   4. 刷新对外部是透明的
   5. 刷新单位必须是行
   6. **地址引脚复用**
      1. 采用行列地址，分为两次输入，引脚数减小一半
      2. 减少地址引脚：行列数尽可能相等
      3. 减少刷新开销：行数小于列数
      4. 地址位数 ：n = r*c，r为行，c为列
      5. 引脚： = log2r+log2c
   7. 行缓冲器：用于缓冲行中每列的数据，**常用于SRAM**
   8. 突发传输
3. SDRAM
   1. 数据交换同步于时钟信号
4. SRAM和DRAM比较
   1. <img src="C:\Users\27545\AppData\Roaming\Typora\typora-user-images\image-20250520160620451.png" alt="image-20250520160620451" style="zoom:25%;" />
5. 存储器芯片的内部结构
   1. 组成
      1. 存储体，io写电路，地址译码器，控制电路
   2. 存储体：存储单元的集合，通过行列选线控制访问单元
   3. 地址译码器
      1. 单译码法：只有一个行译码器
      2. 双译码法：行列译码，交点为所选单元
   4. IO电路：用于控制单元的读和写
   5. 片选控制线：用于控制选择多个存储芯片
   6. 读写控制线：读写命令，控制IO电路

#### 只读存储器

1. 只读存储器的特点
   1. 结构简单
   2. 非易失性
2. 类型
   1. 掩模式只读存储器MROM
      1. 厂商直接写入，不可改
      2. 可靠性高，集成度高，价格便宜，灵活性差
   2. 一次可编程只读存储器PROM
      1. 用户利用编程器写入，只能写一次，不可改
   3. 可擦除可编程只读存储器EPROM
      1. 可以采用特定的方式擦除重写
   4. flash存储器
      1. 特点
         1. 可长期保存，可快速擦除重写
         2. 价格便宜，集成度高
   5. 固态硬盘
      1. 固态电子存储芯片阵列制成的硬盘
      2. 有控制单元和存储单元组成
      3. 保留flash特点，价格高

#### 主存储器的基本组成

1. 存储元件：存储单元，一个存储0或1的记忆单元
2. 存储矩阵：若干个存储元件
3. MDR：位数和数据线的位数相同
4. MAR：位数和地址线的位数相同

#### 多模块存储器

1. 单体多字存储器
   1. 只有指令和数据连续存放的时候才能有效提升速度
2. 多体并行存储器
   1. 每个模块有相同的容量和存取速度
   2. 各模块存在独立的读写控制电路和地址寄存器和数据寄存器
   3. 高位交叉编址
      1. 高位表示模块号，低位表示模块内地址
      2. 特点：只增加了存储空间，没有提高存储器的效率
   4. 低位交叉编址
      1. 低位表示模块号，高位表示模块地址
      2. 轮流访问不同的模块
      3. 轮流启动方式
         1. 每个模块的读写位数等于数据总线的位数，存取周期为T，总线周期r，存储器模块数>= m = T/r
         2. 按照1/m的存取周期轮流启动模块，存取速度提高了m背
         3. 连续存取m个字的时间t = T+（m-1)r
         4. 访问冲突
      4. 同时启动方式
         1. 所有模块的数据总位数 = 数据总线的位数，可将所有模块同时读写

## 主存储器与cpu的连接

#### 连接原理

1. 主存储器通过数据总线，地址总线，控制总线，与cpu连接
2. 数据总线位数 * 工作频率 = k数据传输速率
3. 地址总线位数决定可寻址的最大内存空间
4. 控制总线指出总线周期类型，和输入，输出完成时刻

#### 主存容量的扩展

1. 位扩展
   1. 芯片地址线，片选控制线，读写控制线和系统总线并联
   2. 芯片数据线分别连接系统数据线
2. 字扩展
   1. 芯片的地址线与系统地址线的低位对应连接
   2. 芯片的数据线和读写控制线与系统总线对应并联
3. 字位同时扩展
   1. 连接方式
      1. 将进行位扩展的芯片为一组，各组连接和位扩展相同
      2. 将高位译码产生的片选信号分别连接片选控制线

#### 存储芯片的地址分配和片选

1. 线选法
   1. 高位片选线，低位片内地址
   2. 每个线对应一个芯片
   3. 线路简单，空间不连续，地址浪费
2. 译码片选法
   1. 3 8 译码器
   2. 2 4 译码器

#### 存储器和cpu的连接

1. 合理选择存储芯片
2. 地址线的连接
3. 数据线的连接
4. 读写控制线的连接
5. 片选控制线的连接

## 外部存储器

#### 磁盘存储器

1. 特点
   1. 存储容量大，位价低
   2. 介质可重复利用
   3. 长期存储
   4. 非破坏读出
   5. 存取速度慢，机械结构
2. 组成
   1. 磁盘驱动器：控制磁盘转动和读写
   2. 磁盘控制器：接收cpu命令，发生各种控制信号
3. 存储区域
   1. 扇区：读写的最小单元
   2. 磁头数：也就是面数
   3. 柱面数：表示磁道数
   4. 扇区数：每条磁道上的扇区个数，（内外磁道个数相同）
4. 磁盘的高速缓存
5. 磁记录原理
   1. 磁头和磁性记录介质相对运动，通过电磁转换完成读写操作
   2. 通常使用FM和MFM记录方式
6. 磁盘的性能指标
   1. 记录密度；盘片单位面积的二进制数据量
   2. 磁盘的容量
      1. 非格式化容量：可利用的磁化单元总数
         1.  = 记录面数*柱面数\*每条磁道的磁化单元数
      2. 格式化容量 = 记录面数*每道扇区数\*每个扇区的容量
   3. 存取时间 = 寻道时间+旋转延迟时间+传输时间
      1. 寻道时间：最外道到最内道的一半
      2. 旋转延迟时间：旋转半周时间
   4. 数据传输速率
      1. Dr = rN，r为磁盘转速，N为磁道容量
7. 磁盘地址
   1. 柱面号，盘面号，扇区号
8. 磁盘工作过程
   1. 寻址，读盘，写盘

1. 磁盘阵列
   1. RAID：独立冗余磁盘阵列
   2. RAID0:：无冗余无校验的磁盘阵列
   3. RAID1：镜像磁盘阵列 1：1
   4. RAID2:采用纠错的海明码磁盘阵列 
   5. RAID3:位交叉奇偶校验磁盘阵列
   6. RAID4 ：块交叉奇偶校验磁盘阵列
   7. RAID5 ： 无独立校验的奇偶校验的磁盘阵列
   8. 从上到下依次变好

#### 固态硬盘

1. 特性
   1. 容量更大，性能更好
   2. 一个或者多个flash组成
   3. 一个flash有多个块，一个块有多个页
   4. 读快，写慢
   5. 写操作需要，当写的位置存在数据，需要将数据复制，然后擦除，然后写
2. 磨损均衡
   1. 动态磨损均衡
      1. 优先擦除次数少的新flash块
   2. 静态磨损均衡
      1. 老的闪存担任读任务，新的担任写任务

## 高速缓冲存储器

#### 程序访问的局部性原理

1. 时间局部性
   1. 未来用的信息可能是现在的信息
2. 空间局部性
   1. 未来访问的信息可能是现在的信息的下一个
3. 行列存储访问的空间局部性

#### cache的基本工作原理

1. cache和主存都被分为大小相等的块，主存更多
2. cpu发出读请求，先访问cache，地址在cache则访问命中，就直接对cache操作
   1. 不命中，访问主存，并将此块调入cache
   2. cache满的时候，根据替换算法替换cache原有块
   3. **数据交换以字为单位**
3. cpu写请求
   1. cache命中，可能存在cache与主存不一直，按照写策略进行写入
4. **命中率**
   1. H = Nc/(Nc+Nm)，Nc表示cache命中次数，Nm表示主存命中次数
5. 访问时间
   1. T = Htc + （1-H)tm （cache和主存同时访问），tc表示cache访问时间，tm表示主存访问时间
   2. T = Htc +（1-H）（tc+tm）（先访问cache，再访问主存）

#### cache和主存的映射关系

1. cache的每一行都有标记位（主存编号），有效位（cache块是否有效）
2. 直接映射
   1. 主存每一块只能放入cache唯一位置
   2. cache行号 = 主存块号 % cache行数
   3. **地址结构**
      1. 标记，cache行号，块内地址
      2. 标记位位数 = 主存位-cache位
3. 全相联映射
   1. 每一块都可以放入cache任意位置
   2. 特点
      1. cache冲突概率低
      2. 空间利用率高
      3. 命中率高
      4. 标记速度慢
      5. 成本高
   3. 地址结构
      1. 标记，块内地址
      2. 标记位数 = log2主存块数
   4. 原理
      1. 将标记位进行比较，相等且有效位为1命中
   5. 按内容寻址的相联存储器，开销大
4. 组相联映射
   1. 将cache分成Q个组，每个主存块可以存入一个组的任意一行
   2. 地址结构
      1. 标记位，组号，块内地址
      2. 组号 = 主存块号%cache组数
   3. 原理
      1. 先访问对应cache组，将对应行的标记位和主存比较，相等且有效位为1，命中
   4. 比较器的个数和分组内的路数相同
5. **cache的标记项结构**
   1. 有效位
   2. 脏位：判断是否写入数据
   3. 替换控制位
   4. 标记位：控制对应主存块
6. **比较**
   1. 直接映射命中率最低，全相联最高
   2. 直接映射开销最小，时间最短，全相联开销最大，时间最长
   3. 直接额外空间开销小，全相联额外空间开销大

#### cache中主存块的替换算法

1. 随机算法RAND：随机替换cache行
2. 先进先出FIFO：最早的cache行替换
3. 近期最少使用算法LRU：依据时间局部性原理，选择时间长未访问的替换
   1. 对每一个cache行设置计数器
   2. 命中，计数器清零，其他计数器加1
   3. 未命中，无空闲，计数最高替换
   4. 未命中，有空闲，放入，计数0，其他加1
   5. 手算
4. 最不经常使用算法LFU：每行也设置计数器，记录总的计数值

#### cache的一致性问题

1. 全写法
   1. 当写命中时，对cache和对应主存块都写入
   2. 写缓冲，cpu将数据写入cache和写缓冲，写缓冲再慢慢写入主存
2. 回写法
   1. 只写入cache，只有当cache块替换时，才写回主存，每行设置脏位控制是否被写入
3. 写分配
   1. 当不命中，更新主存，然后调入cache
4. 非写分配
   1. 不命中，只更新主存，不调入cache
5. 全写和非写分配配合，回写和写分配配合

#### 多级cache





