# 计算机系统概述

## 计算机发展历程

1. 第一代：电子管
2. 第二代：晶体管
3. 第三代：中小规模集成电路
4. 第四代：大规模，超大规模集成电路

## 计算机系统层次结构

#### 计算机系统组成

1. 硬件系统
2. 软件系统

#### 计算机硬件

1. 冯若依曼计算机特点
   1. 采用存储程序的工作方式
   2. 硬件系统有运算器，存储器，控制器，输入设备，输出设备组成
   3. 指令和数据以同等地位存储在存储器
   4. 指令和数据都以二进制的形式存储
   5. 指令有操作码和地址码组成
2. 计算机的功能部件
   1. 输入设备
   2. 输出设备
   3. 存储器
      1. 分为主存储器（内存），辅助存储器（外存）
      2. MAR：储存器地址寄存器
         1. 用于存放访问地址，经过地址译码后找到所选存储单元
         2. 反应了存储单元的个数
      3. MDR：存储器数据寄存器
         1. 用于按存储单元的地址存取
         2. 等于存储字长
   4. 运算器
      1. 累加器：ACC
      2. 乘商寄存器：MQ
      3. 操作数寄存器：X
      4. 变址寄存器：IX
      5. 基址集训期：BR
      6. 算术逻辑单元：ALU
   5. 控制器
      1. 计数器：PC
      2. 指令寄存器：IR
      3. 控制单元：CU

#### 计算机软件

1. 系统软件和应用软件
2. 三个级别的语言
   1. 机器语言:二进制代码语言
   2. 汇编语言
   3. 高级语言
   4. 汇编程序:将汇编语言翻译为机器语言
   5. 解释程序：**将源程序的语句逐条翻译为机器指令并立即执行**
   6. 编译程序：将高级语言翻译为汇编或机器语言
3. 
4. 软件和硬件的逻辑等价性
   1. 对于某一功能既可以使用软件进行实现，也可以硬件实现

#### 计算机系统的层次结构

1. 微程序机器层
2. 传统机器语言层
3. 操作系统层
4. 汇编语言层
5. 高级语言层
6. ISA：指令体系结构

#### 计算机系统的工作原理

1. 存储程序的工作方式
   1. 取指令
      1. PC-MAR-M-MDR-IR
   2. 分析指令
      1. OP（IR）-CU
   3. 执行指令
      1. Ad(IR)-MAR-M-MDR-ACC
2. 从源程序到可执行文件
   1. 预处理器cpp：预处理，得到.i文件
   2. 编译器ccl：编译,等到.s文件，汇编语言
   3. 汇编器as：汇编，得到.o文件，机器语言
   4. 链接器ld：得到可执行文件.exe

## 计算机的性能指标

#### 计算机的主要性能指标

1. 机器字长

   1. 计算一次整数运算所能处理的二进制的位数
   2. 等于通用寄存器的位数和ALU的宽度

2. 数据通路带宽

   1. 总线一次能够并行传输的信息的位数

3. 主存容量

   1. 主存储器的最大容量
   2. 等于MAR*MDR

4. 运算速度

   1. 吞吐量和响应时间
      1. 吞吐量：系统在单位时间内处理请求的数量
      2. 响应时间：用户发送请求，计算做出响应并取得结果的时间
   2. 主频和cpu时钟周期
      1. cpu时钟周期
         1. 机器内部主时钟脉冲信号的宽度，**cpu的最小工作时间**
      2. 主频
         1. 机器内部主时钟的频率，**时钟周期的倒数**
      3. CPI：执行一条指令所用的时钟周期数
      4. IPS：每秒执行ed指令数，**主频/平均CPI**
      5. cpu执行时间
         1. **时钟周期数/主频=（指令条数*CPI）/主频**
      6. 性能：**主频，CPI，指令条数**
      7. MIPS
      8. FLOPS

5. 基准程序


# 数据的表示和运算

## 数制和编码

#### 进位计数制及其相互转换

1. 进位计数制
   1. 常见：二进制，十进制，八进制，十六进制
   2. 基数：表示某一位上的数字
   3. 位权：表示某一位所占的进制次方数
2. 进制互换
   1. 二转八，十六
      1. 3位合一
      2. 4位合一
   2. 转十进制
      1. 数码和权值的乘积和
   3. 十进制转二进制
      1. 除基取余法
         1. 先得到的是低位，最后为高位
      2. 乘积取余法

#### 定点数的编码表示

1. 真值和机器数
   1. 真值：带有正负号的值
   2. 机器数：把正负号变为0和1的数
2. 机器数的定点表示
   1. 定点表示，浮点表示
   2. 计算机中常用
      1. 补码表示整数
      2. 原码表示浮点数的尾数部分
      3. 移码表示浮点数的阶数部分
   3. 定点小数
   4. 定点整数
3. **原码，反码，补码，移码**
   1. 原码
      1. 最高位表示符号，其余各位表示数的绝对值
      2. 字长为n+1时，整数范围-（2^n- 1) <= x <= 2^n -1
      3. 特点
         1. 真值转换简单
         2. 乘除实现简单
         3. 0的表示不唯一，存在两中表示
         4. 加减复杂
   2. 补码
      1. 正数补码等于原码，负数补码等于数值位取反+1
      2. 字长为n+1时，整数范围-2^n <= x <= 2^n-1
      3. 特殊补码
         1. 0补等于-0补，全为0
         2. -1补等于全为1
         3. 2^n-1补为 011111
         4. -2^n的补为 10000
      4. 补码和真值的转换
         1. 正数补码等于原码
         2. 负数时，符号位变1，数值位按位取反+1
         3. 补码转换真值
            1. 正数一样
            2. 负数，变符号位，数制等于按位取反+1
         4. 补码和原码的负数可以通过符号位不变，数值位按位取反+1，互相转换。
   3. 反码
      1. 等于符号位不变，数值位按位取反
      2. 0的表示不唯一
      3. 表示范围少一个-2^n相比补码
   4. 移码
      1. 常用于表示浮点数的阶数
      2. 移码 = 补码+偏移量（ 例：1000,0000）
      3. 机器字长为n+1时，表示-2^n <= x< 2^n
      4. 特点
         1. 0的表示唯一
         2. **浮点数的移码**：是阶码的实际值加上偏移量（Bias）
         3. 整数的移码：**补码和移码可以通过变换符号位互相转换**
         4. 移码保留了原有数据的大小，移码大则真值大，反之亦然
   5. 特点
      1. 原反补，符号位相同，正数都相同
      2. 原，反数轴上对称
      3. 补码，移码数轴不对称，有唯一0，

#### 整数的表示

1. 无符号整数
   1. 全为数值位，没有符号位
   2. 机器字长为n时，表示范围0-2^n-1
2. 有符号整数
   1. 符号位在最前
   2. 常用补码表示
      1. 优势
         1. 0唯一
         2. 多表示一个数
         3. 符号位可以和数值位一起运算

#### C语言中的整数类型和类型转换

1. C语言的整数数据类型
   1. short,int,long
   2. un short,un int ,un long
   3. char
   4. 都是用补码存储
2. 有符号数和无符号数的转换
   1. 转换后的所有位置不变，但是符号位的解释改变
3. 不同字长整数的转换
   1. 小转大
      1. 原数字为无符号：高位补充0
      2. 原数字为有符号：进行符号位扩展
   2. 大转小
      1. 高位删除，低位直接赋值

## 运算方法和运算电路

#### 基本运算部件

1. 一位全加器
   1. 全加器（FA）：最基本的加法单元
   2. 和表达式：Si = Ai 异或 Bi异或 Ci-1
   3. 进位表达式：Ci = AiBi + (Ai异或 Bi)Ci-1
2. 串行进位加法器
   1. 二进制和：S = SnSn-1……S1
3. 并行进位加法器
   1. 通过已知的直接求出所有进位的值
   2. 递推公式
4. 带标志加法器
   1. 有符号溢出标志：OF  = Cn异或Cn-1，通过最后两位的进位可以判断
   2. 有符号正负标志：SF = Fn-1，即为第一位的0或1表示正负
   3. 零标志位：ZF = 1表示结果为0，反之不为0
   4. 无符号溢出标志：CF = Cout 异或 Cin ,可以通过输出进位，输入进位判断
5. 算数逻辑单元ALU
   1. 包含两个输入端，一个操作控制端ALUop，四个标志位，一个加法输出结果，一个输入进位和输出进位

#### 定点数的移位运算

1. 逻辑移位
   1. 左移，高位移出，低位补0,
   2. 右移，低位移出，高位补0
   3. **无符号整数左移，高位1移出则发生溢出**
      1. 例：假设有一个8位无符号整数`10000000`（十进制的128），左移1位后会变成`00000000`（因为最高位的1被移出了存储范围），但实际上，正确的数学结果应该是256，但8位无符号整数无法表示256，因此发生了溢出。
2. 算术移位
   1. 将操作数视为有符号数
   2. 左移，高位移出，低位补0，如果，移位后的最高位不同于原来的，则发生溢出
   3. 右移，低位溢出，高位补0，如果，低位是1时，移出影响精度

#### 定点数的加减运算

1. 补码的加减法运算
   1. 运算特点
      1. 逢二进一
      2. 加法直接加，减法，被减数加上减数的负数的补码
      3. 符号位数值位一起加，符号位也直接得出
      4. 高位丢弃
   2. 补码的负数：**补码按位取反+1**
2. 溢出的判断
   1. 两个正数或者两个负数相加时会发生溢出
   2. 一位符号位
      1. 符号位表示As，Bs
      2. V = AsBs非Ss + 非（AsBs）Ss,即为当两个符号都为1时且相加符号位不为1，两个符号位都为0，相加符号位为1,时溢出
   3. 双符号位
      1. 表示00，结果为正数，无溢出
      2. 表示01，结果为正溢出
      3. 表示11，结果为负数，无溢出
      4. 表示10，结果为负数，负溢出
      5. V = Ss1异或Ss2，即为两个符号位不同时溢出
   4. 一符号位根据数值位的进位判断溢出
      1. V = Cn 异或 Cn-1,同OF的表达
3. 加减运算电路
   1. 组成
      1. 两个输入端，被加数接多路选择器（用于判断，加减法，加法直接加，减法，变为补码的负数加）
      2. sub，控制信号
      3. CIn，Cout输入输出进位
      4. 加法器
      5. 四个标志位和结果
   2. 无符号数的大小比较
      1. ZF等于1，A=B,表示相减为0
      2. ZF为0，CF=1，则A<B
      3. ~,CF = 0,则A>B
   3. 有符号的大小比较
      1. ZF =1 ,A等于B
      2. ZF = 0，SF = 1，OF为1时，表示正-负导致溢出，A>B
      3. ~，SF = 0，OF = 0，表示正减正，且A>B
      4. ~，SF = 1，OF = 0，A<B
      5. ~,SF =0 , OF= 1 ,表示负减正溢出，A<B
      6. **SF == OF则A>B,反之小于**
4. 原码的加减法
   1. 加法
      1. 同号求和，异号求差
   2. 减法
      1. 减号符号位取反，加法求和

#### 定点数的乘除运算

1. 定点数的乘法运算

   1. 原码乘法
      1. 符号位为原来两个符号位异或
      2. 数值位为两个乘数的绝对值之积
      3. 过程
         1. n次加法，n次移位
         2. 被乘数与乘数都以绝对值相乘
         3. 部分积PI表示乘法运算的中间结果
         4. Pi = 2^-1（Pi-1 + XYn-i)
            1. 2-1表示将结果右移一位
            2. X为被乘数，Y为乘数
            3. n-i表示的进行的第几轮，Y的第几位
   2. 补码乘法
      1. 过程
         1. n次加法，移位
         2. 每次加法的加数
            1. 辅助位-MQ最后一位 = 0，加0
            2. 等于1 ，加X补
            3. 等于-1，加-X补
         3. **辅助位，开始为0，可以每次右移后改变为MQ的最后一位**
         4. MQ的最后一位表示Yn-i
   3. 乘法电路
      1. 组成
         1. 被乘数寄存器：X
         2. 乘积寄存器：P（部分积）
         3. 乘积寄存器：Y
         4. C:进位
         5. 控制逻辑计数器：Cn
         6. 每次乘积完成后将CPY右移，低位舍弃

2. 除法运算

   1. 恢复余数法

      1. 符号位单独处理，两个异或
      2. 默认先上一，如果相减后为负数，则上0,，并将余数恢复
      3. 上0，则ACC+除数，一次加法后，ACC，MQ整体左移，ACC高位丢弃，低位补0
      4. 最后得到的商的位数等于机器字长

   2. 加减交替法

      1. 如果余数为负，则直接商0，让余数左移一位再加上除数得到新余数
      2. 余数为正，则让余数左移1一位，再减去除数得到新余数

   3. 定点小数的除法**规定被除数小于除数**

   4. 补码的除法运算

      1. 加减交替法
         1. 符号位参与运算
         2. 被除数，余数，除数采用双符号位
         3. 被除数和除数同号，则被输出减去除数，异号则加上除数
         4. 余数和除数同号则，上1，余数左移一位再减去除数
         5. 余数和除数异号，上0，余数左移一位，再加上除数
         6. 重复n次
         7. 末尾商恒为1

   5. 除法运算电路

      1. 组成

         1. 除数寄存器

         2. 余数寄存器

         3. 余数，商寄存器

         4. 逻辑控制器


## 浮点数的表示和运算

#### 浮点数的表示

1. 浮点数的表示格式
   1. N = （-1)s* M * R^E
   2. s表示正负，M为一个二进制的定点小数
   3. R为基数（进制），E为阶码或指数
2. 浮点数的表示范围
   1. 浮点数原码关于原点对称
   2. -（1-2^-24)*2^63~-2^24\*2^-64  2^-24\*2^-64 ~ (1-2^-24)\*2^63
   3. 大于正整数为正上溢出，小于最小负数为负上溢
   4. 正下溢，负下溢，通常表示为0
3. 浮点数的格式化
   1. 左规：尾数最高位不是有效位，尾数每左移一位，阶码减一
   2. 右规：尾数的大小绝对值应该大于1/2小于1，尾数每右移一位，阶码加一，可能导致溢出
4. IEEE 754标准
   1. 32位 1 8 23
   2. 64位 1 11 52
   3. 分别表示1为符号位，阶码，尾数
   4. 754的标准下尾数为大于1小于2
   5. **隐藏位：尾数的第一位一定为1，但是一般隐藏**
   6. 阶码 = 真值+偏置值
   7. **表示范围**
      1. 阶码e范围：1-254（32位）,1-2046(64位)
      2. 最小值为e = 1,尾数为0，则最小值为1*2^e-127,最大值为e = 254,尾数为1-2^-23，最大值为（2-2^-23)\*2^127
      3. 同理可知64位
   8. 特殊表示
      1. 正负0，符号位不同，其他全为0
      2. 正负无穷，符号位不同，阶码最大，尾数为0
      3. 无定义数，符号位不同，阶码全1，尾数不为0
      4. 非规格化正负数，符号位不同，阶码为0，值为正负2^-126* ( 0.f),:用于处理阶码下溢
   9. 定点和浮点的表示区别
      1. 数值的表示范围
      2. 精度
         1. 浮点数的精度降低了
      3. 数的运算
         1. 运算复杂
      4. 溢出问题

#### 浮点数的加减运算

1. 对阶
   1. 将两个操作数的小数点位置对齐，阶码相等，用小阶码向大阶码看齐的方式进行**尾数右移产生的低位不要移出，保留参加运算**
2. 尾数加减
   1. 将尾数加上隐藏位后一起进行加减运算
3. 对尾数重新规格化
4. 舍入
   1. 就近舍入，将尾数舍入为最近的值，如果距离一样，则舍入为偶数的值
   2. 正项舍入，将尾数向增长的方向舍入
   3. 负项舍入，将尾数向减小的方向舍入
   4. 截断法，直接截取所需要的位数
5. 溢出判断
   1. 如果正指数大于了最大值，则发生指数上溢
   2. 如果一个负指数小于了最小值，则发生指数下溢
   3. 右规导致指数上溢
   4. 左规导致指数下溢

#### C语言中的浮点数类型

1. 不同类型元素混合运算遵循的原则为整形提升
2. int 转float 需要舍入处理，影响精度
3. int float 转double，不影响
4. double，可能发生溢出，也可能舍入
5. float double，可能溢出，舍入

#### 数据的大小端和对齐存储

1. 数据的大端和小端方式存储
   1. 大端：高位存高位，低位存低位
   2. 小端：高位存低位，低位存高位
2. 数据按照边界对齐的方式存储
   1. 按照字进行存储
   2. 不按照





